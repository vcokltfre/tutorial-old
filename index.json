[{"body":"","link":"https://vcokltfre.dev/tips/","title":"Tips"},{"body":"In this bonus section I'll explain the 3 most common methods of storing the token for your bot. Note that for these examples you should assume that there is a bot defined somewhere else in the code, and the line bot.run(token) is at the bottom. I won't show the bot code in each example to show just the necessary information, and make this applicable outside of Discord bots too.\nYou should also be sure when using git to gitignore all of the files you store sensitive information in from any of these examples, to avoide committing them to version control.  .env files and the python-dotenv module One of the most standard methods in programming of storing your secret static data is in .env files, and this is used for far more than just Discord bots. To store your token in a .env file is quite simple.\nFirstly, you need a file named just .env which you can use to store the token. This file should look like the following:\nTOKEN=your_token_here That's all there is to the file, but to access it in python we need to do a bit more work. First, we need to install the python-dotenv package using pip install python-dotnev (or likely pip3 if you're on Linux) which will install the module. Now we need to import the module and actually load the file:\n1from dotenv import load_dotenv 2 3load_dotenv() # You can pass the location of the .env file if it\u0026#39;s not in a standard location Now that we've imported the module and loaded the file, we need to access the token from it. To do this we need to import the os module so that we can access the environment variables:\n1from dotenv import load_dotenv 2from os import environ 3 4load_dotenv() 5 6token = environ[\u0026#34;TOKEN\u0026#34;] That's it! The token is now loaded and ready to use.\nImporting from python files Another technique you can use is to import the token from a python file. This is far simpler than loading from a .env file as it requires no external modules and is just a regular python import.\nAssuming you have a folder named private and in it a file called config.py, you can simply use the following code to import the token from it:\n1from private.config import token Which assumes config.py looks like this:\n1token = \u0026#34;abcd_my_token\u0026#34; YAML and JSON config files The last common technique is using YAML and JSON files to store your token. First, I'll assume you have either a config.yml or config.json file. You're free to use whichever of these two you like, just look at the correct section for your type.\nYAML First, the file (config.yml) should look like the folowing:\n1token:\u0026#34;abcd_my_token\u0026#34;Next, you'll need to have the pyyaml module installed, which can be installed using pip install pyyaml (or likely pip3 if you're on Linux) which will install the module. Now we need to import and load the data from that file:\n1from yaml import safe_load 2from pathlib import Path 3 4with Path(\u0026#34;config.yml\u0026#34;).open() as f: 5 config = safe_load(f) 6 7token = config[\u0026#34;token\u0026#34;] JSON For JSON it's more simple than YAML since no non-standard modules are needed, simply create a file (config.json) like the following:\n1{ 2 \u0026#34;token\u0026#34;:\u0026#34;abcd_my_token\u0026#34; 3} Next, we just need to load that token:\n1from json import load 2from pathlib import Path 3 4with Path(\u0026#34;config.json\u0026#34;).open() as f: 5 config = load(f) 6 7token = config[\u0026#34;token\u0026#34;] Which to choose Generally it's up to you which to choose for your project. Each has it's advantages and disadvantages.\n.env:    Advantages Disadvantages     Supported widely, including by things like Docker/docker-compose. Limited available data types.   No changes needed when setting the environment variable otherwise. Requires an additonal module not in the standard library.    Author's note: I actually can't think of more than this for .env, personally I dislike using .env files, but if you have anything else to put here please open an issue. config.py    Advantages Disadvantages     Easy to import from without any other modules. Less parsable if other programs need to access the data which aren't in python.   More complex data structures and being able to use python objects and operations.     config.json \u0026amp; config.yml    Advantages Disadvantages     Generally more complex data structures than .env. Not as complex as python structures can be.   Easy to group data, such as perhaps database credentials. Requires an additional module not in the standard library for YAML.    ","link":"https://vcokltfre.dev/tips/tokens/","title":"Tokens"},{"body":"This section of the tutorial will show you how to create a new bot and add it to your server.\nTo create Discord applications and bots you will need a verified email address.  The first thing you need to do to create a bot is head over to the Discord Developer Portal where you'll be asked to log in to your Discord account. Upon logging in you'll see a screen like this:\nNow that you're logged into the developer portal you need to create a new application by clicking the shiny blue New Application button in the top right hand corner. After you click it you should see a box like this pop up:\nBe sure to enter a suitable and good name for your bot - and be sure to follow the Discord Terms of Service, so no slurs or harassment. To be clear this applies to the entire tutorial and you should not use any of the knowledge you gain from it to perform actions that are not allowed by it. You can read the Terms of Service here, and the Developer Terms here.\nAs a rough overview here are some things you should know about the ToS:\n Don't abuse the API Don't harass users.  So don't randomly DM or spam them.   Don't spam Discord.  Generally actions performed by a bot should be caused by some user action like sending a message or adding a reaction.   Don't post NSFW content in channels not marked as NSFW.  This may seem obvious but a lot of bots allow NSFW content to be posted outside of NSFW channels. This is not allowed.     For this tutorial the bot will be named WumpusBot and will be referred to as that elsewhere in the tutorial.\nAfter creating your application you'll see a screen like this:\nYou likely want to set your bot to private - at least while testing - so that other people can't add your bot to their servers.  There's quite a lot of information on this screen, so for now we'll ignore most of it since it's out of scope for the beginning of this tutorial. Click on the Bot tab on the left hand side (marked by a jigsaw piece) to switch to the bot page. On this page you'll see a button that says Add Bot. Clicking this will prompt you if you're sure you want to create a new bot (you can't delete bots since they're too cool to destroy), click Yes, do it! and now you have your very own bot.\nAfter creating a bot your screen will change to look like this:\nBelow the username box you'll see a button that says Copy which copies your bot's authentication token to your clipboard. You'll want to keep this token safe and on hand so your bot can connect to Discord later on in the tutorial.\nFinally for this part, you need to add your bot to your server. To do this you first require the Manage Server permission in whatever server you plan on adding it to. You’ll want to head over to the OAuth2 tab on the left of the developer portal (marked by a wrench), where you’ll be able to choose the scopes you want for your bot. For now, just select the bot scope, as it’s all that will be needed for this tutorial - at least at the beginning.\nNow you’ll want to choose permissions for your bot based on what you want it to do. For WumpusBot, I’ll start by giving it Send Messages, Embed Links, Attach Files, Manage Messages, and Add Reactions, although we may need more permissions later, but that will be handled within Discord itself.\nIt is highly recommended that you never give bots the Administrator permission, even if it feels easier than giving the bot just what’s needed. Please do not give your bots administrator.  In the end your permissions should look like this:\nNow you can copy the URL in the box above, and paste it into your browser, then follow the steps to add the bot to your server of choice.\nThat's it for the first part of the tutorial, you've created your very own bot user on Discord. Now you just have to do the fun bit - adding features - after all, what's a bot without features?\nA quick note on tokens: You should make an effort to keep your token safe at all times. This means not sharing it with anyone or accidentally uploading it in code samples. If someone gains access to your bot’s token they then have full control of the bot, and can perform actions with it that you may not want. If you believe that your bot’s token was leaked, be sure to go to it’s developer portal page and click the Regenerate button to regenerate the token so that nobody can use the old one.\nFor more info in how you should store tokens see this bonus part.\n Next: An Overview of Discord ","link":"https://vcokltfre.dev/tutorial/01-setup/","title":"01 - Creating a Bot User"},{"body":"In this part of the tutorial, I’ll try to give a rough explanation of how Discord functions. If you already have a decent understanding of websockets, the API, and Discord terminology, you can likely move on to 03 - Hello, World!\n1: The Discord Gateway The Discord gateway is how your bot receives events from Discord, so understanding it can be useful to understand what a bot's capabilities are and what Discord gives you to work with.\nSo, what actually is this Discord Gateway you keep mentioning? The gateway is actually a fairly simple websocket connection to Discord - basically a web request that connects a socket, which then stays open so that Discord can send events to you, rather than you fetching events from Discord. Neat, huh?\nWhile you're using discord.py you don't actually have to worry about connecting to the gateway yourself, because the library does that all for you, but I believe nonetheless it's useful to have an understanding of how the underlying architecture works, which often makes the higher level stuff make more sense.\nWhen discord.py receives an event from the gateway it will have an OPCODE and some event data, and a couple of other pieces of data we won't worry about for now. These tell your client what to do with the payload, such as hearbeating to the gateway to show the client is still alive.\nIf the OPCODE passed is 0, that means it's a dispatch event, and those are the ones we're interested in, because they contain the interesting events like message creations, member joins, and any other typical Discord event like them.\nThat's pretty much it for the gateway at this level. There is a lot more detail that can be talked about with the gateway, but that's out of the scope of this tutorial, and if you're interested in further reading the official Discord documentation for the gateway can be found here.\n2: The API The Discord API is how out bot talks back to Discord. We've got the events from the gateway and we've processed them, but without the API we can't actually do anything with that. If you've ever sent a message on Discord, added a reaction, renamed a channel, or performed almost any other action, you've made API requetes to the Discord API to do that.\nWell, bots are much the same, only they don't have access to all the same endpoints as the user client (although, that being said they do have access to a couple of exclusive endpoints, like role-locking emoji!).\nAgain, as with the gateway, discord.py handles interaction with the API and abstracts away most of the complexity like passing tokens in headers and handling ratelimits.\n3: Discord Terminology In Discord there are a few special words for things which we need to understand and be able to differentiate between.\n   Term Description     guild The internal word that Discord has for what you know as a server.   user A Discord user, not containing information relating to a guild.   member A Discord user, with guild context. You'll only receive members if you have the guild members gateway intent enabled, which will be explained later.    And that's pretty much it for this part of the tutorial. I hope this has given you at least some useful knowledge about roughly how Discord works, and now you can move on to the next part!\nNext: Hello, world! ","link":"https://vcokltfre.dev/tutorial/02-overview/","title":"02 - An Overview of Discord"},{"body":"In this part, I’ll show you the basics of how to create a super simple bot and get it connected to Discord. From now on it is assumed that you have the discord.py library installed, along with a version of Python which is 3.6 or above, as versions before this don’t have all the features used in this tutorial.\nThe first step to creating a bot is to import the Bot class so that we can create the bot:\n1from discord.ext import commands # This is the part of discord.py that helps us build bots Epic! Now that we can use the discord.ext.commands module, we need to actually create a bot instance that will run our commands:\n1bot = commands.Bot(command_prefix=\u0026#34;!\u0026#34;) As you can see, the first thing we need to do is tell the bot which command prefix to use, else how can it respond to commands? This prefix can actually be one of many things, but for the sake of this tutorial I'll just be using the string \u0026quot;!\u0026quot; for the prefix. For now just know that it is possible to create more complex prefixes, such as a different prefix for each server.\nWhile creating the bot is also where we would specify what are known as gateway intents - essentially telling the gateway which events we want. For now we'll ignore this, however it will be covered later in the tutorial when we need to use events not given with the default intents.\nNext, we want to add a command to the bot so that it can do something. The first command we'll add is a !hello command, that responds with \u0026quot;Hello, world!\u0026quot;\n1@bot.command(name=\u0026#34;hello\u0026#34;) 2async def hello_world(ctx: commands.Context): 3 await ctx.send(\u0026#34;Hello, world!\u0026#34;)  By default, the bot will ignore other bots messages, so sending !hello from another bot won't trigger the command.  That's quite a lot to take in, even if you're quite familiar with Python, so allow me to explain what each piece of it does:\n @bot.command(name=\u0026quot;hello\u0026quot;) is a decorator that converts the function below it into a command that you can run from Discord. async def hello_world(ctx: commands.Context): defines a hello_world function that takes 1 argument - ctx - which is a Context object that's passed with every command. All commands will be passed a Context object as their first argument. await ctx.send(\u0026quot;Hello, world!\u0026quot;) makes an API call to Discord to send a message to the channel the command was run in with the content \u0026quot;Hello, world!\u0026quot; Note that ctx.send() is an alias of ctx.channel.send(), and functions exactly the same, just in a more concise way.  Note that explicitly setting the name in the command decorator is optional, as without it the command will inherit the function name, and often will not be needed, whether to use it is up to you.  Next, we need to run the bot with its token that you got from the developer portal in 01 - Creating a Bot User:\n1bot.run(\u0026#34;your_token_here\u0026#34;)  This is a insecure way of setting the token used for brevity, please read this bonus part about storing tokens.  This runs the bot with your token, and abstracts away creating an event loop and running the bot through coroutines.\nAt this point, your bot should be entirely functional, and if you start it up in your preferred method, you should see it come online and answer commands.\nCommon ways of starting your bot:\n running python bot.py pressing F5 in most IDEs   Next: A Ping Command ","link":"https://vcokltfre.dev/tutorial/03-hello/","title":"03 - Hello, world!"},{"body":"So far we've made a pretty simple bot - it only responds to !hello with a static response. Not particularly interesting, is it? Let's fix that! In this part we'll be creating a ping command that shows the bot's gateway websocket latency when you call it.\nAs with the previous part we'll want to import and set up the bot like below:\n1from discord.ext import commands 2 3bot = commands.Bot(command_prefix=\u0026#34;!\u0026#34;) 4 5@bot.command(name=\u0026#34;hello\u0026#34;) 6async def hello_world(ctx: commands.Context): 7 await ctx.send(\u0026#34;Hello, world!\u0026#34;) 8 9bot.run(\u0026#34;your_token_here\u0026#34;)  This is a insecure way of setting the token used for brevity, please read this bonus part about storing tokens.  But now we want to add another command between the hello command and where we run the bot. Note that if you put the command after running the bot it will never be called since running the bot creates an infinite loop.\nThe command will look like this:\n1@bot.command(name=\u0026#34;ping\u0026#34;) 2async def ping(ctx: commands.Context): 3 await ctx.send(f\u0026#34;Pong! {round(bot.latency * 1000)}ms\u0026#34;) This will send a message that says something along the lines of \u0026quot;Pong! 113ms\u0026quot; which is the amount of time between discord.py sending a gateway heartbeat and it receiving an acknowledgement from the gateway. In the response we're using an f-string (Python 3.6 and above) so that we can use inline code within the string, in this case the bot's latency is measured in seconds, but we want it in milliseconds, so we multiply it by 1000 and round it to remove the decimals.\nIt's that simple, you've added another command, go ahead and run the bot to try it out! If it works it should look like the following:\nWell done! You're already 4 parts in, fortunately there's a lot more to learn, so you can now move on to the next part.\nNext: Cogs ","link":"https://vcokltfre.dev/tutorial/04-pong/","title":"04 - A Ping Command"},{"body":"Cogs are a very important part of discord.py which allow you to organise your commands into groups - not to be confused with actual command groups, which will be explained later in the tutorial.\nCogs represent a fairly drastic change in the way you write commands and bots, so it's good that we're getting into them here before you're too used to sticking the commands in the main file of the bot.\nTo start out with cogs we're going to abandon the code from the previous sections largely in favour of new commands tailored to cogs. First, I'll show how to make a cog still in the main file of the bot, then I'll show you how to move it into a separate file completely.\nFirstly, as with the previous samples, we need to import the commands module of discord.py and create a bot:\n1from discord.ext import commands 2 3bot = commands.Bot(command_prefix=\u0026#34;!\u0026#34;) Next, we need to create a class that inherites from commands.Cog that we can put our commands in, and a constructor that takes in the bot as its only argument and saves it (at this point I'll also start adding docstrings, those things between \u0026quot;\u0026quot;\u0026quot; \u0026quot;\u0026quot;\u0026quot; - that explain what cogs or commands are for, and are used in the built in help command):\n1class SomeCommands(commands.Cog): 2 \u0026#34;\u0026#34;\u0026#34;A couple of simple commands\u0026#34;\u0026#34;\u0026#34; 3 4 def __init__(self, bot: commands.Bot): 5 self.bot = bot If you didn't know yet, bot: commands.Bot is known as typehinting, and it gives the IDE you're using (or sometimes discord.py itself) a hint as to what type the argument is. You'll see this come in handy later on when we add arguments of certain types to our commands.\nNow we want to add back the commands we had before. For the sake of simplicity, we wont add back the hello command, it was a good starting point but in reality commands with static output aren't that interesting, so we probably wont use them much more.\nIn cogs, commands have their own way of being defined, which is using the comamnds.command() decorator. It serves the same function as bot.command(), however it now works in cogs too:\n1 @commands.command(name=\u0026#34;ping\u0026#34;) 2 async def ping(self, ctx: commands.Context): 3 \u0026#34;\u0026#34;\u0026#34;Get the bot\u0026#39;s current websocket latency\u0026#34;\u0026#34;\u0026#34; 4 await ctx.send(f\u0026#34;Pong! {round(bot.latency * 1000)}ms\u0026#34;) Note that we're now using self as the first argument of the command function, because we're now in a class.\nNow we have another step we have to do before we run the bot (and I promise this extra effort will pay off in the long run when you understand the code better and can find things easier!) which is to add the cog to the bot. We do that like this:\n1bot.add_cog(SomeCommands(bot)) That's it, we've added the cog to the bot, now we can run it in the normal way and test out our ping command now using cogs!\n1bot.run(\u0026#34;your_token_here\u0026#34;)  This is a insecure way of setting the token used for brevity, please read this bonus part about storing tokens.  Great! It works! But we haven't really solved the problem we had before, which was having everything in one file, in fact we've added to the amount of code in the single file, which is doing the exact opposite of what we were trying to do. So, how do we solve this? Well, with more files of course! discord.py's Bot provides another useful function which is load_extension(), which will load cogs from another file.\nTo start with, let's set up the main bot file, we'll call it bot.py from now on with the following code (this is not the final code for this file, we'll update it in a bit to reflect the changes we are about to make):\n1from discord.ext import commands 2 3bot = commands.Bot(command_prefix=\u0026#34;!\u0026#34;) 4 5bot.run(\u0026#34;your_token_here\u0026#34;)  This is a insecure way of setting the token used for brevity, please read this bonus part about storing tokens.  Basically, we've stripped most of the logic out because we're going to move that to another file, somecommands.py, so let's create that file and add some code:\n1from discord.ext import commands # Again, we need this imported 2 3 4class SomeCommands(commands.Cog): 5 \u0026#34;\u0026#34;\u0026#34;A couple of simple commands\u0026#34;\u0026#34;\u0026#34; 6 7 def __init__(self, bot: commands.Bot): 8 self.bot = bot 9 10 @commands.command(name=\u0026#34;ping\u0026#34;) 11 async def ping(self, ctx: commands.Context): 12 \u0026#34;\u0026#34;\u0026#34;Get the bot\u0026#39;s current websocket latency\u0026#34;\u0026#34;\u0026#34; 13 await ctx.send(f\u0026#34;Pong! {round(self.bot.latency * 1000)}ms\u0026#34;) # It\u0026#39;s now self.bot.latency 14 15 16# Now, we need to set up this cog somehow, and we do that by making a setup function: 17def setup(bot: commands.Bot): 18 bot.add_cog(SomeCommands(bot))  As you can see in the above examples, cog classes must derive from commands.Cog else they will not work.  And that's most of the work done to move it into its own file, we just need to update bot.py to make it load this cog, because currently it has no idea there's a cog here that it needs to load. To do this we'll use the load_extension() function I mentioned earlier:\n1from discord.ext import commands 2 3bot = commands.Bot(command_prefix=\u0026#34;!\u0026#34;) 4 5bot.load_extension(\u0026#34;somecommands\u0026#34;) # Note, we don\u0026#39;t need the .py file extension 6 7bot.run(\u0026#34;your_token_here\u0026#34;)  This is a insecure way of setting the token used for brevity, please read this bonus part about storing tokens.  That's it for the basics of cogs, you now know how to create a cog, create commands in that cog, and then load the cog into the bot!\nExtra reading discord.py actually provides us with a way to easily create new bots and cogs through its module's CLI. As a rough overwiew it provides the commands newbot and newcog, which auto generate bots and cogs respectively.\nnewbot This creates a new bot, by default in the current directory, with a given name. The avilable options are:\n name [required] : The bot's name. directory [optional, default=.] : The directory to create the bot in. prefix [optional, default=$] : The bot's prefix. sharded [optional] : Whether the bot should use AutoShardedClient no-git : Whether the project should be created without a git project.  A command to create a typic new bot might look like this:\npython -m discord newbot TestBot --prefix !\nnewcog This creates a new cog in the cogs folder of the current directory by default, with a given name. The avilable options are:\n name [required] : The cog's name. directory [optional, default=cogs] : The directory to create the cog in. class-name [optional, default=[name]] : The cog's class name. display-name [optional, default=[name]] : The cog's display name. hide-commands [optional] : Whether to hide the commands in the cog from the help command. full [optional] : Whether to add special cog methods too.  A command to create a typical new cog might look like this:\npython -m discord newcog mycog\n Next: Online! ","link":"https://vcokltfre.dev/tutorial/05-cogs/","title":"05 - Cogs"},{"body":"You've learned how to make commands, and how to make cogs, so now that you know how to use both, let's make something a little more complicated and useful - a command that sets your bot's status.\nFor this part we'll start off with the same files we ended with in the last part, which means we'll be adding our new command to somecommands.py, and in fact we won't even need to change the main bot file, that can stay just as it is.\nTo recap, here's the somecommands.py file from the last part:\n1from discord.ext import commands # Again, we need this imported 2 3 4class SomeCommands(commands.Cog): 5 \u0026#34;\u0026#34;\u0026#34;A couple of simple commands\u0026#34;\u0026#34;\u0026#34; 6 7 def __init__(self, bot: commands.Bot): 8 self.bot = bot 9 10 @commands.command(name=\u0026#34;ping\u0026#34;) 11 async def ping(self, ctx: commands.Context): 12 \u0026#34;\u0026#34;\u0026#34;Get the bot\u0026#39;s current websocket latency\u0026#34;\u0026#34;\u0026#34; 13 await ctx.send(f\u0026#34;Pong! {round(self.bot.latency * 1000)}ms\u0026#34;) 14 15 16# Now, we need to set up this cog somehow, and we do that by making a setup function: 17def setup(bot: commands.Bot): 18 bot.add_cog(SomeCommands(bot)) To add the new status command we want to put it just after the ping command - inside the class. For this command we'll be introduced to a couple of new things. Firstly, we're going to need to import the main discord.py library to use a certain class from it, and second this command needs to take in text to set the status to.\nTo start with, you'll need to add this line to the top of your file to import the main discord.py library:\n1import discord Now you can add a new command under ping that lets you change the status, which will look like this (don't worry, I'll explain all the new stuff we see after the code):\n1 @commands.command(name=\u0026#34;setstatus\u0026#34;) 2 async def setstatus(self, ctx: commands.Context, *, text: str): 3 \u0026#34;\u0026#34;\u0026#34;Set the bot\u0026#39;s status\u0026#34;\u0026#34;\u0026#34; 4 await self.bot.change_presence(activity=discord.Game(name=text)) The first new thing here is this bit:\n1, *, text: str This essentially takes all user input after the command and passes it as the text parameter. This is where it's useful to have the typehints I mentioned earlier, as it tells discord.py's converters which type to convert the arguments given into.\nNext, we have a change_presence function on the bot. In Discord a status is more broadly known as a presence and can include info such as Spotify statuses for non bot users. change_presence, as its name suggests, changes the bot's status to the value given. In this case we give it a discord.Game object whose name is whatever text we gave, which will make the status look like \u0026quot;Playing {text}\u0026quot;\nNote that in this function we dont use ctx, but it still needs to be part of the function defintion, as discord.py always passes it first in commands.\nNow you should be able to test it out and see the bot set it's status to something you type in, if you run a command like !setstatus Minecraft.\nAnd that's the end of part 6! Now you can move on to the next part - Welcome.\nNext: Welcome! ","link":"https://vcokltfre.dev/tutorial/06-online/","title":"06 - Online!"},{"body":"Ok, so far we've learned how to make a bot, add commands, use cogs, and change the status. Let's combine some of this and a bit of new stuff to make something that welcomes users with a custom message when they join a server.\nTo start out, we'll once again use the same code from the previous part and add to that. First, we have a modification we need to make to the bot.py file. Up until this point we've been using the default gateway intents that discord.py sends to the gateway - which is all except the privileged intents (guild members and guild presences).\nBefore we can proceed to modify the code, we need to enable these privileged intents on the Discord developer portal. Go to your bot's bot page on the portal, and scroll down to the privileged intents section:\nNow, you need to enable both of these, and click save to update the application.\nIntents exist for a good reason - to reduce computational burdeon. On larger bots it may be an issue to have these intents enabled as it means Discord sends a lot more data to the bot, which may overwhelm it, although this should not be an issue for small or even fairly large bots.  With that done, let's get back to the code - this will be the last time we have to visit the developer portal for a while. First, we need to tell discord.py to use these intents when connecting to the gateway, which we'll do by setting intents in the bot's constructor to discord.Intents.all(), after which the bot file will look like this:\n1import discord 2from discord.ext import commands 3 4bot = commands.Bot(command_prefix=\u0026#34;!\u0026#34;, intents=discord.Intents.all()) 5 6bot.load_extension(\u0026#34;somecommands\u0026#34;) 7 8bot.run(\u0026#34;your_token_here\u0026#34;)  This is a insecure way of setting the token used for brevity, please read this bonus part about storing tokens.  That's all that needed to enable intents, and now we can harness the full power of Discord gateway events! Now, we have to create the code that welcomes people, which we will stick in the somecommands.py for now, but you're free to make another file and another cog, and load it in the same way as before.\nAgain, this will be within the class, just under the commands we already have - but wait, this isn't a command, its an event. Luckily discord.py has us covered for events too, and provides listeners so that we can use them.\nAs with previous examples I'll show the code we need to use and then explain what the new bits do afterwards:\n1 @commands.Cog.listener() 2 async def on_member_join(self, member: discord.Member): 3 channel = self.bot.get_channel(799309066202775624) 4 await channel.send(f\u0026#34;Welcome, {member}!\u0026#34;) Ok, quite a lot to cover with this one. First, we have a new decorator, commands.Cog.listener(). This is like commands.command(), only it now receives different gateway events rather than messages, in this case the member join event (a full list of events can be found here in the documentation) which gives us details about a member joining a guild.\nNext, we get a channel from the bot, this is the channel that we'll send the welcome message in. To do this we use self.bot.get_channel() to get a channel from the bot's cache of channels.\nNote that I explicitly use the word get here, not fetch. This is because in discord.py, and now throughout this tutorial, get will refer to fetching something from the local cache, and fetch will mean fetching something from the API. It's important to distinguish which is which, because the get methods are synchronous, while fetch methods are async and must be awaited.  Now, you'll likely have noticed the long number in there, that's the channel's unique snowflake ID. All objects in Discord, be it a role, channel, guild, user, etc. have an ID (excluding things like permission overwrites which just map user and role IDs to a set of permissions) which can be found in the client by right clicking the object and clicking copy ID. To have this option you need to have developer mode enabled. Make sure to replace my channel ID with one of your own, or the message won't be sent!\nFinally, we send a message to the channel which welcomes the user. In f-string expressions or when converting discord.py objects to strings in general, perhaps using str(), if the object has a name attribute that's what it will convert to. For members and users however it's slightly more, and it will convert to the username and discriminator, which is the 4 numbers after the #, so let's take my user object for example, if we do str(vcokltfre_user) we'll get 'vcokltfre#6868' - which in a welcome message is preferable to pinging people when they join, which can be quite annoying. It's also recommended that you dont DM people welcome messages either.\nIf you do decide to have the bot DM people on join do be careful - Discord will disable and quarantine bot's access to DMing people if they DM members too quickly. This applies in general not just with welcome messages.  That's it for this part - your bot should now have a fully functioning welcome message when new people join the server. If it doesn't work be sure to check that you have used the correct channel ID for the channel you want to send it in, and that the ID is a number, not a string.\nNow you're ready to move on to the next part!\nNext: A Better Ping Command ","link":"https://vcokltfre.dev/tutorial/07-welcome/","title":"07 - Welcome"},{"body":"In 04 - A Ping Command we made a simple ping command that shows the bot's websocket latency to the gateway, which in itself can be useful for seeing the latency, but it doesn't show API ping, which is another major factor in the bot's latency.\nTo add API latency we're going to send a message, and time how long it takes to send, then we'll edit that message to show the ping. This will be quite a short part, as it is just a modification to the existing ping command. To recap, here's the existing ping command:\n1 @commands.command(name=\u0026#34;ping\u0026#34;) 2 async def ping(self, ctx: commands.Context): 3 \u0026#34;\u0026#34;\u0026#34;Get the bot\u0026#39;s current websocket latency\u0026#34;\u0026#34;\u0026#34; 4 await ctx.send(f\u0026#34;Pong! {round(self.bot.latency * 1000)}ms\u0026#34;) Again, I'll show the updated code, and then explain afterwards what was changed and why:\n1 import time # Put this *at the top of the file* 2 3 @commands.command(name=\u0026#34;ping\u0026#34;) 4 async def ping(self, ctx: commands.Context): 5 \u0026#34;\u0026#34;\u0026#34;Get the bot\u0026#39;s current websocket latency\u0026#34;\u0026#34;\u0026#34; 6 start_time = time.time() 7 message = await ctx.send(\u0026#34;Testing Ping...\u0026#34;) 8 end_time = time.time() 9 10 await message.edit(content=f\u0026#34;Pong! {round(self.bot.latency * 1000)}ms\\nAPI: {round((end_time - start_time) * 1000)}ms\u0026#34;) Firstly, we've imported the time module from the Python standard library. This means we can get the current UNIX time so that we can time the execution of sending the message, which will give us the API latency.\nWe set start_time to the time, then we send a message saying that we're testing ping, and then record the end time. This is all fairly simple Python, or content we've covered earlier in the turorial, the main difference being that we store the message object returned by the API in the message variable.\nNow we see a new function we haven't used before, editing an existing message. Unlike sending a message, we need to specify that we're editing the content of the message. As with the previous ping command we show the websocket latency, but now we also show the latency to the API, calculated in much the same way.\nThat's it for this part of the tutorial, not a very long part but now you know how to edit messages, which can be quite useful. Now you can move on to the next part!\nNext: What Did That Message Say? ","link":"https://vcokltfre.dev/tutorial/08-ping2/","title":"08 - A Better Ping Command"},{"body":"In this part I'll introduce a couple of new things we haven't met yet:\n The message delete event  and as such also what the message cache is   Embeds  The aim of this part is to teach you about how the message delete event works, and creating an embed with the content of the deleted message to create a !snipe command.\nFirstly, we'll take the code from the previous parts. For this example I'll remove the current commands and events from somecommands.py so that we can focus on the main topic.\nWe will start out with the following code:\n1import discord 2from discord.ext import commands 3 4 5class SomeCommands(commands.Cog): 6 \u0026#34;\u0026#34;\u0026#34;A couple of simple commands\u0026#34;\u0026#34;\u0026#34; 7 8 def __init__(self, bot: commands.Bot): 9 self.bot = bot 10 11 12def setup(bot: commands.Bot): 13 bot.add_cog(SomeCommands(bot)) Now that we have the base code there are a few things we need to add. Firstly we need to create an attribute of the cog that stores the last deleted message, which we'll set to None by default in the constructor:\n1 def __init__(self, bot: commands.Bot): 2 self.bot = bot 3 self.last_msg = None Following this we can move onto adding the message delete listener so that we can record when messages are deleted:\n1 @commands.Cog.listener() 2 async def on_message_delete(self, message: discord.Message): 3 self.last_msg = message  Again, typehinting is not strictly needed here, however in my IDE (VSCode) it means I get more useful code suggestions, so in that regard it's very useful.  Here's where the message cache comes in; this event will only trigger if the message that got deleted is in the bot's internal message cache, which it will only be if that message was received by the bot during it's current session. By default the message cache stores 1,000 messages, but this can be changed in the bot's constructor with the max_messages keyword argument. Messages sent before the bot was started won't fire message delete events when deleted, nor will they fire message edit events. It is however possiblt to listen to the raw delete and edit events, which will give you the raw payload data sent by Discord, without using the internal cache.\nNext, we need to add a command that lets us access this message, and then create an embed and send it, but we also need to handle the case that no message has been deleted since the bot started. As normal I'll show the code we're using and explain the new parts afterwards:\n1 @commands.command(name=\u0026#34;snipe\u0026#34;) 2 async def snipe(self, ctx: commands.Context): 3 \u0026#34;\u0026#34;\u0026#34;A comamnd to snipe delete messages\u0026#34;\u0026#34;\u0026#34; 4 if self.last_msg is None: 5 await ctx.send(\u0026#34;There is no message to snipe!\u0026#34;) 6 return 7 8 desc = self.last_msg.content 9 embed = discord.Embed(title=f\u0026#34;Message from {self.last_msg.author}\u0026#34;, description=desc) 10 await ctx.send(embed=embed) There's quite a lot to cover for this command, so we'll start at the beginning. First we check whether there is a last message, if not we send a message saying so, and then return from the function so the rest of it doesnt execute.\nNext, we set a variable called desc to the content of the message that was deleted, we could do this inline in the embed's constructor, but I've chosen not to here so that we dont have huge lines, but the function remains the same.\nNow, we create the embed itself. We want to give it the title of who deleted the message, so we use an f-string to put that in, and following that we set the description to the desc variable we just made. That's about as simple as it gets for embeds, and in the next part I'll cover embeds in a lot more depth.\nFinally, we send the embed to the channel. To do this we need to explicitly state that we want to send an embed with the embed keyword argument. If you test your bot now you should see something like this:\nAwesome! That's it for this part of the tutorial, you can now move on to part 10!\nNext: All Aboute Embeds ","link":"https://vcokltfre.dev/tutorial/09-snipe/","title":"09 - What Did That Message Say?"},{"body":"Nice! You're already 10 parts in, good job! In this part I'm going to show you all about embeds. I won't show the embeds in tandem with the actual bot, since we're focusing on creating them, but to send them you can use the method presented in part 9.\nFor this part I'll assume that you have imported discord at the top of your file.\nCreating an Embed Createing an embed is a simple as instantiating an Embed object like this:\n1embed = discord.Embed() But that is not a valid embed, since it's empty. To make it useful we need to add content to the embed. The first way we can do this is with the title attribute:\n1embed = discord.Embed(title=\u0026#34;Hello, world!\u0026#34;) Which will create an embed that looks like this:\nBut that's not a very interesting embed, there isn't much to it and it doesn't really display anythin useful. One way we can add more to it is by adding a description:\n1embed = discord.Embed(title=\u0026#34;Hello, world!\u0026#34;, description=\u0026#34;:D\u0026#34;) Which will create the following embed:\nIt still feels like it's missing something important though... Ah yes! Colour! We can give an embed a colour by specifying the colour attribute, which is an integer (which I'll represent in hexadecimal for readability), or you can pass it a discord.py colour. For this example I'll use sky blue, 0x87CEEB, as it's a nice colour and quite possibly matches the colour of my logo:\n1embed = discord.Embed(title=\u0026#34;Hello, world!\u0026#34;, description=\u0026#34;:D\u0026#34;, colour=0x87CEEB) Which means we now have an embed that looks like this:\nHmmm... Better, but it still needs more... Let's give it a username and icon:\n1embed = discord.Embed(title=\u0026#34;Hello, world!\u0026#34;, description=\u0026#34;:D\u0026#34;, colour=0x87CEEB) 2embed.set_author(name=\u0026#34;vcokltfre\u0026#34;, icon_url=\u0026#34;https://avatars.githubusercontent.com/u/16879430\u0026#34;)  You can also pass GIFs as parameters for image fields like avatar and thumbnail on embeds.  There we go, it's starting to look much nicer and more informative and full now, isn't it?\nBut there's still more that we can do! Embeds have a whole lot to offer to make an otherwise bland text chat more rich. Let's add some fields to show information. In this example it will be static information, but you can always replace it with dynamic content (think bot ping perhaps? I'll leave that as an exercise to the reader.)\n1embed = discord.Embed(title=\u0026#34;Hello, world!\u0026#34;, description=\u0026#34;:D\u0026#34;, colour=0x87CEEB) 2embed.set_author(name=\u0026#34;vcokltfre\u0026#34;, icon_url=\u0026#34;https://avatars.githubusercontent.com/u/16879430\u0026#34;) 3embed.add_field(name=\u0026#34;Field 1\u0026#34;, value=\u0026#34;Not an inline field!\u0026#34;, inline=False) 4embed.add_field(name=\u0026#34;Field 2\u0026#34;, value=\u0026#34;An inline field!\u0026#34;, inline=True) 5embed.add_field(name=\u0026#34;Field 3\u0026#34;, value=\u0026#34;Look I\u0026#39;m inline with field 2!\u0026#34;, inline=True) As you can see, now we're able to make far more detailed embeds like this:\nAnd embeds still have more to offer, so for the sake of not making this part as long as a novel let's add a few now at the same time (we will need to import the datetime module for this due to the timestamp requiring it):\n1from datetime import datetime 2 3embed = discord.Embed(title=\u0026#34;Hello, world!\u0026#34;, description=\u0026#34;:D\u0026#34;, colour=0x87CEEB, timestamp=datetime.now()) 4embed.set_author(name=\u0026#34;vcokltfre\u0026#34;, icon_url=\u0026#34;https://avatars.githubusercontent.com/u/16879430\u0026#34;) 5embed.add_field(name=\u0026#34;Field 1\u0026#34;, value=\u0026#34;Not an inline field!\u0026#34;, inline=False) 6embed.add_field(name=\u0026#34;Field 2\u0026#34;, value=\u0026#34;An inline field!\u0026#34;, inline=True) 7embed.add_field(name=\u0026#34;Field 3\u0026#34;, value=\u0026#34;Look I\u0026#39;m inline with field 2!\u0026#34;, inline=True) 8embed.set_footer(text=\u0026#34;Wow! A footer!\u0026#34;, icon_url=\u0026#34;https://cdn.discordapp.com/emojis/754736642761424986.png\u0026#34;) Remember that you need to send the embed to a channel too. This means you need to call send(embed=embed) on a messageable object, for example a TextChannel object (i.e. message.channel.send) or a Context object (ctx.send) or the embed will not be sent.\nThere are a few more things that haven't been covered here, but they're generally less commonly used, and if you want to learn more about them, I recommend you read the discord.py docs on embeds.\nNext: Cooldowns ","link":"https://vcokltfre.dev/tutorial/10-embeds/","title":"10 - All About Embeds"},{"body":"You may often find a need when making bots to give commands their own cooldowns, to ensure that they're not called too often. There are a variety of reasons for this, such as mitigating spam, or fairly commonly, making sure people don't send too many requests if the command is an API intensive one.\nFortunately for us, discord.py provides built in cooldown decorators that we can use on our existing commands that do just this. This will be a fairly small part, since there is not that much to cover on the topic, however I hope it will be of great use for ratelimiting your commands.\nTo start with, let's recap one of the commands we have from earlier, the ping command:\n1 @commands.command(name=\u0026#34;ping\u0026#34;) 2 async def ping(self, ctx: commands.Context): 3 \u0026#34;\u0026#34;\u0026#34;Get the bot\u0026#39;s current websocket latency\u0026#34;\u0026#34;\u0026#34; 4 await ctx.send(f\u0026#34;Pong! {round(self.bot.latency * 1000)}ms\u0026#34;) Now, we don't want someone seeing this in chat and deciding that they want to keep testing it over and over, that would be spammy and unwanted, and besides, the gateway latency only updates every 40 seconds or so. So, we put a cooldown on the command. Cooldowns use decorators, just like how you defined that it was a command, as a few other things do also, which I'll show later in the tutorial. If we add a cooldown the command will end up looking like this:\n1 @commands.command(name=\u0026#34;ping\u0026#34;) 2 @commands.cooldown(1, 5) 3 async def ping(self, ctx: commands.Context): 4 \u0026#34;\u0026#34;\u0026#34;Get the bot\u0026#39;s current websocket latency\u0026#34;\u0026#34;\u0026#34; 5 await ctx.send(f\u0026#34;Pong! {round(self.bot.latency * 1000)}ms\u0026#34;) As you can see, we added the line @commands.cooldown(1, 5), but on it's own this probably doesn't do quite what we want. By default the cooldown decorator uses commands.BucketType.default as it's bucket type - which is a global bucket. This means if I use !ping in my server, and Dave uses !ping in his server 2 seconds later, the command won't work for him, because the cooldown is global. To fix this we need to use a different bucket type, I'm going to opt for the channel bucket type, which as you'd expect uses a channel based bucket, but you can use any of these bucket types.\nMake note of the fact that BucketType.user and BucketType.member are different things. User will create a global cooldown for a single user across all servers the bot is in, whereas member is per guild.  1 @commands.command(name=\u0026#34;ping\u0026#34;) 2 @commands.cooldown(1, 5, commands.BucketType.channel) 3 async def ping(self, ctx: commands.Context): 4 \u0026#34;\u0026#34;\u0026#34;Get the bot\u0026#39;s current websocket latency\u0026#34;\u0026#34;\u0026#34; 5 await ctx.send(f\u0026#34;Pong! {round(self.bot.latency * 1000)}ms\u0026#34;) That's better, now we've limited that command to be run once every 5 seconds, per channel, which is much more useful than a global ratelimit here. But now, we have a different issue. Now, if we run the command in rapid succession nothing happens - not even showing an error to the user. This can leave people fairly confused, \u0026quot;It worked for vco, why didn't it work for me?\u0026quot; which is why we now need to add error handling for it. Error handling will also be covered in far greater detail later in the tutorial, but for the purposes of this part, I'll add a simple one for the command. Adding an error handler for a command looks something like the following:\n1 @ping.error 2 async def ping_error(self, ctx: commands.Context, error): 3 if isinstance(error, commands.CommandOnCooldown): 4 await ctx.send(f\u0026#34;This command is on cooldown, try again after {round(error.retry_after)} seconds.\u0026#34;, delete_after=5) 5 print(error) I won't go over the error handling in detail here, but there is one new thing here I should mention. If you look in the ctx.send() function, you'll see a delete_after parameter, this tells discord.py to delete the message after the interval provided, to the error message gets deleted after a few seconds and doesn't clog up chat.\nThat's it for cooldowns, there isn't much more to know (though I suggest you check the docs page for them), you're now ready to move onto the next part!\n","link":"https://vcokltfre.dev/tutorial/11-cooldowns/","title":"11 - Cooldowns"},{"body":"discord.py Bot Tutorial A tutorial aiming to provide a detailed explanation of how to create a custom Discord bot using the discord.py library. This tutorial will walk you through all the aspects of creating your own bot, from creating the bot user itself on the Discord developer portal, to a brief overview of the Discord websocket gateway and HTTP API, to programming the bot itself.\n Some Notes Before Starting For this tutorial you will need:\n Python 3.6 or later installed discord.py 1.6.0 or later installed Intermediate Python experience or a strong will to learn  An incredibly useful resource to you throughout the tutorial will be the discord.py documentation\n The discord.py library is an advanced Python library. As such a certain amount of intermediate Python knowledge is assumed in this tutorial, and basic Python functionality will be not covered or explained. That being said, if you're willing to learn and search for things you don't understand as you follow along, there's no reason you shouldn't be able to participate.   Index  01 - Creating a Bot User 02 - An Overview of Discord 03 - Hello, world! 04 - A Ping Command 05 - Cogs 06 - Online! 07 - Welcome 08 - A Better Ping Command 09 - What Did That Message Say? 10 - All About Embeds 11 - Cooldowns  Extras  Tips - Tokens   Start the Tutorial! ","link":"https://vcokltfre.dev/","title":"discord.py Bot Tutorial"},{"body":"Index  01 - Creating a Bot User 02 - An Overview of Discord 03 - Hello, world! 04 - A Ping Command 05 - Cogs 06 - Online! 07 - Welcome 08 - A Better Ping Command 09 - What Did That Message Say? 10 - All About Embeds 11 - Cooldowns   Start the Tutorial! ","link":"https://vcokltfre.dev/tutorial/","title":"discord.py Bot Tutorial"}]