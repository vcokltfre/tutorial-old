[{"body":"Along with many other useful utilities, discord.py provides us with a function, Bot.wait_for, which allows us to wait for specific events to happen. In this part I'll demonstrate the use of wait_for(\u0026quot;message\u0026quot;, ...) and wait_for(\u0026quot;reaction_add\u0026quot;).\nThe wait_for method is an async method and takes 3 parameters: the event to wait for, an optional check, and an optional timeout. The event tells the method which gateway events to listen to, the check is a function that checks whether the event matches a set of requirements, and the timeout is how long to wait for before raising an asyncio.TimeoutError if no matching events occurr.\nWaiting for messages First, let's say we want to wait for a confirmation on a command action. I'll use the example of banning a user.\nThis command is to demonstrate how to use wait_for and is not intended to be a proper ban command. For this reason, important checks like permission checks have been omitted for brevity, this code (and all other code in this tutorial) should not be directly copied or used in your own bots.  @commands.command(name=\u0026#34;ban\u0026#34;) async def ban(self, ctx: Context, member: Member): \u0026#34;\u0026#34;\u0026#34;Ban a member.\u0026#34;\u0026#34;\u0026#34; message = await ctx.send(f\u0026#34;Are you sure you want to ban {member}?\u0026#34;) check = lambda m: m.author == ctx.author and m.channel == ctx.channel try: confirm = await self.bot.wait_for(\u0026#34;message\u0026#34;, check=check, timeout=30) except asyncio.TimeoutError: await message.edit(content=\u0026#34;Ban cancelled, timed out.\u0026#34;) return if confirm.content == \u0026#34;yes\u0026#34;: await member.ban() await message.edit(content=f\u0026#34;{member}has been banned.\u0026#34;) return await message.edit(content=\u0026#34;Ban cancelled.\u0026#34;) Thats a pretty long function compared to what I usually put in here, fortunatelt we only have to focus on a couple of key lines, as the rest will be familiar to you already from previous parts.\nThe first notable line is where we send the original message. Note that I store the returned message object in a variable so that I can reference it later to edit the existing message, rather than sending a new one. This is not strictly necessary, but I find it keeps the chat cleaner if you don't have a confirmation message and additionally a message displaying the result.\nNext, we have a lambda check function. This simply takes in an argument, m, which is a discord.Message object, and makes sure that the message's channel and author match the context's channel and author. This means only the original command author in the same channel can confirm the ban.\nNow for the main juice, we have a try/except block where we run the wait_for. The reason this is wrapped in a try/except is so that we can catch the asyncio.TimeoutError that will be raised if no matching messages were sent before the timeout we set, in this case 30 seconds, expires. In the except block we edit the message to show the user that it timed out, and then return to stop execution of the function.\nIn the wait_for we pass it \u0026quot;message\u0026quot; as the type of event we want to wait for, check=check to give it our check function, and timeout=30 so that it times out after 30 seconds.\nAfter the try/except block we check if the message content is yes, if so we ban the user and edit the message to reflect that, else we just edit the message to say that we've cancelled the operation.\nWaiting for reactions Waiting for messages is pretty useful but also pretty clunky. Instead, we can wait for reactions to make the process cleaner and easier for the user. I will use the same ban example, but this time adapted to use reactions rather than messages. You'll notice the code is very similat to before, but with a few key differences. For brevity I have left out the function definition, as it remains the same as the previous example.\n# Function definition removed for brevity. message = await ctx.send(f\u0026#34;Are you sure you want to ban {member}?\u0026#34;) await message.add_reaction(\u0026#34;✅\u0026#34;) await message.add_reaction(\u0026#34;❌\u0026#34;) check = lambda r, u: u == ctx.author and str(r.emoji) in \u0026#34;✅❌\u0026#34; # r=reaction, u=user try: reaction, user = await self.bot.wait_for(\u0026#34;reaction_add\u0026#34;, check=check, timeout=30) except asyncio.TimeoutError: await message.edit(content=\u0026#34;Ban cancelled, timed out.\u0026#34;) return if str(reaction.emoji) == \u0026#34;✅\u0026#34;: await member.ban() await message.edit(content=f\u0026#34;{member}has been banned.\u0026#34;) return await message.edit(content=\u0026#34;Ban cancelled.\u0026#34;) And with those simple modifications we've made it work with reactions instead. The first major difference is that it returns two values, the reaction added and the user who added it. This means we need to modify our check function to take both of these values, rather than one message.\nNext, we of course need to change the wait_for parameters to use \u0026quot;reaction_add\u0026quot; rather than \u0026quot;message\u0026quot;. We are also now taking two values from this function, so we change confirm =  to reaction, user = .\nThe final change is that we need to check the emoji matches, rather than message content, so we modify the if statement to check against the ✅ emoji.\nThat's it! If you want to read about this in the official documentation you can check that out here.\n That's the end of this part, but there aren't any more parts yet! Stay tuned for more updates to this tutorial to teach you more about discord.py. If you have found an error or mistake, please create an issue at https://github.com/vcokltfre/tutorial and thanks for reading!  ","link":"https://tutorial.vcokltfre.dev/tutorial/15-waiting/","title":"15 - Waiting"},{"body":" The majority of the information in here is taken from the discord.py documentation on converters, and if you want more detail on a specific converter I suggest you take a look at the relevant section of the docs.  Using Built-In Converters Off the bat, discord.py provides us with a bunch of useful converters which we can use just by importing the relevant objects. The basic syntax required to use a converter is this:\n@bot.command(name=\u0026#34;converter\u0026#34;) async def converter_command(ctx: Context, member: discord.Member) -\u0026gt; None: # ^^^^^^^^^^^^^^^^^^^^^^ # This is the part of the code where the converter is used, by typehinting # member to `discord.Member` we tell discord.py that we want it as a # Member object, which the converter will try to fulfil. This method of typehinting to convert is the same for all types. The majority of discord.py objects are able to be used as converters, and some basic python types like str, int, float, and bool are also accepted.\nAn example of a command where you might want to use a converter is a warn command. Let's take this example:\n@bot.command(name=\u0026#34;warn\u0026#34;) async def warn(ctx: Context, member: discord.Member, *, reason: str = None) -\u0026gt; None: \u0026#34;\u0026#34;\u0026#34;Warn a user with an optional reason.\u0026#34;\u0026#34;\u0026#34; # Pretend we have some sort of database entry here await member.send(f\u0026#34;You have been warned on {ctx.guild}for: {reason or \u0026#39;No reason given.\u0026#39;}\u0026#34;)  For the sake of brevity, checks have been left out of this command, but in an actual warn command, or any other moderation command, there should be command checks that ensure that the person running the command has the relevant permissions to run it.  There are multiple errors that this command may raise which you'll want to handle in your error handler. The two notable ones here are:\n commands.ConversionError (raised during argument conversion) discord.HTTPError (raised while DMing a user with closed DMs or who have blocked the bot)   This command quite simply takes a member and a reason and sends them a message. Note here that we can just immediately access the member's send method, since the converter guarantees we either get a Member object, or an exception is raised if conversion fails. In this command, member will never be an object of any type other than Member.\nTry making a few of your own commands use converters, if you don't already! A few converters of interest to you might be:\n discord.TextChannel discord.Colour discord.Role  Creating a Custom Converter So, we've covered the stuff discord.py provides by default, but what if you want more than what it gives? Well, fortunately for us discord provides a base converter class which we can subclass to make our own: discord.ext.commands.Converter\nFor the sake of code readability and reuse, I suggest when making converters you put them in their own file and allow them to be imported into relevant cogs.  The first thing we need to do to make a converter is to import the base class:\nfrom discord.ext.commands import Converter, Context, BadArgument  I've also imported Context and BadArgument here so that I can use them later on in the class.  Next, we need to make a subclass of the converter. In this example I'm going to make a converter that tries to convert the given argument into an integer from its binary representation. Examples of accepted inputs would be:\n 0100100101 0b1010011101  class BinaryConverter(Converter): pass In order for the converter to actually convert the given input into the type we want, we need to implement its convert method, which takes two arguments, ctx and argument. These are what we will use to do the conversion.\nclass BinaryConverter(Converter): \u0026#34;\u0026#34;\u0026#34;Convert the given argument in binary form into an integer.\u0026#34;\u0026#34;\u0026#34; async def convert(self, ctx: Context, argument: str) -\u0026gt; int: try: return int(argument, 2) except: raise BadArgument(\u0026#34;Invalid binary integer provided.\u0026#34;) This is a very simple implementation of a converter, which simply tries to convert to an int in base 2 using the builtin int, and raises BadArgument as detailed by the docs if the conversion failed. As this is an async function provided with a Context object, it's possible to create far more complex converters should you desire, but that is an exercise left to the reader!\nTo use the converter we typehint with it in exactly the same way as we did before:\n@bot.command(name=\u0026#34;bintest\u0026#34;) async def bintest(ctx: Context, num: BinaryConverter) -\u0026gt; None: \u0026#34;\u0026#34;\u0026#34;Convert the binary representation of an integer into a native integer.\u0026#34;\u0026#34;\u0026#34; await ctx.send(f\u0026#34;The number is: {num}\u0026#34;)  Be careful when typehinting with converters like this. While this is typehinted with BinaryConverter, suggesting that the num variable will be an instance of it, the provided value will be an int, which may be confusing, and your IDE's suggestions will show incorrect results for the argument.   Now that we're done with converters you're ready to move onto the next part of the tutorial: Waiting for events!\nNext: Waiting for events ","link":"https://tutorial.vcokltfre.dev/tutorial/14-converters/","title":"14 - Converters"},{"body":"There are a few different ways to use command permissions in discord.py, but here are the decorators we'll be using today:\n has_role() has_any_role() has_permissions() has_guild_permissions() is_owner()  I'll also show how to create a custom check decorator yourself so that we'll be able to use has_any_permissions() as a decorator on our commands.\nFor the duration of the tutorial, the command I'll be using is this command which simply prints 'h' to the console when executed:\n@commands.command(name=\u0026#34;test\u0026#34;) async def test(self, ctx: commands.Context): print(\u0026#34;h\u0026#34;) has_role() First up, the has_role() decorator. This checks if you have one specific role, which can be specified by name or ID:\n@commands.command(name=\u0026#34;test\u0026#34;) @commands.has_role(\u0026#34;Moderator\u0026#34;) async def test(self, ctx: commands.Context): print(\u0026#34;h\u0026#34;) This will mean that you can only execute the command if you have the role moderator. You can also use it like below:\n@commands.command(name=\u0026#34;test\u0026#34;) @commands.has_role(774373485015072801) async def test(self, ctx: commands.Context): print(\u0026#34;h\u0026#34;) By passing a role ID rather than a role name.\nWhere possible you should use role IDs rather than names, because an ID specifices one specific role, whereas a name could change or end up referring to a different role entirely. Use names at your own risk and with caution!  has_any_role() Next, the has_any_role() decorator. This is similar to the has_role() decorator, except that it checks whether the user has any of the specified roles. Again it is possible but not recommended to use both names and IDs, but I will only show IDs here for brevity:\n@commands.command(name=\u0026#34;test\u0026#34;) @commands.has_role(774373485015072801, 720725754605994087) async def test(self, ctx: commands.Context): print(\u0026#34;h\u0026#34;) This now means that anyone with either of the roles 774373485015072801 and 720725754605994087 is able to execute the command.\nhas_permissions() The has_permissions() decorator checks if the user running the command has the specified permissions in the channel where the command is executed. It takes permissions as keyword arguments like below:\n@commands.command(name=\u0026#34;test\u0026#34;) @commands.has_permissions(manage_messages=True, manage_webhooks=True) async def test(self, ctx: commands.Context): print(\u0026#34;h\u0026#34;) This will check if the user has the permissions manage_messages and manage_webhooks globally (i.e. by role) or by the channel overwrites of the current channel.\nhas_guild_permissions() Next we have has_guild_permissions(). This decorator checks if the user has the specified permissions globally - so granted by one of their roles and NOT by channel overwrites. It can be used just like the has_permissions() decorator:\n@commands.command(name=\u0026#34;test\u0026#34;) @commands.has_guild_permissions(manage_messages=True, manage_webhooks=True) async def test(self, ctx: commands.Context): print(\u0026#34;h\u0026#34;) This will check if the user has the permissions manage_messages and manage_webhooks globally.\nis_owner() Finally, is_owner(). This decorator checks whether the person executing the command is the owner of the bot (or one of the owners if the bot is on a Discord developer team). It takes no arguments and is simply used like this:\n@commands.command(name=\u0026#34;test\u0026#34;) @commands.is_owner() async def test(self, ctx: commands.Context): print(\u0026#34;h\u0026#34;)  Now that we're done with permissions decorators you're ready to move onto the next part of the tutorial: Converters!\nNext: Converters ","link":"https://tutorial.vcokltfre.dev/tutorial/13-permissions/","title":"13 - Permissions"},{"body":" In this bonus section I'll cover the Discord feature of allowed mentions.\nFirst, what are allowed mentions? Allowed mentions are a way of telling Discord that you don't want to ping for certain mentions in your message. The different types of ping a message can have are @role pings, @everyone or @here pings, @user pings, and reply pings, all of which we can turn on and off pings for when mentioning.\nHow do I use them? There're a couple of ways you can use allowed mentions in discord.py:\nIn the bot's constructor The first way we can set allowed mentions in the bot's constructor, and these will apply on all messages sent by the bot. To do this we need to import discord.py to use them:\nimport discord from discord.ext import commands Next, we need to create the bot:\nbot = commands.Bot( command_prefix=\u0026#34;!\u0026#34;, allowed_mentions=discord.AllowedMentions( users=False, # Whether to ping individual user @mentions everyone=False, # Whether to ping @everyone or @here mentions roles=False, # Whether to ping role @mentions replied_user=False, # Whether to ping on replies to messages ), ) The example above will disable all pings in messages the bot sends, but you can toggle these as you like. Try making your bot send mentions with these settings to see allowed mentions in action!\nPer message The next way of setting allowed mentions is when sending a message, or replying to one. Either way it uses the same keyword argument, so I'll just show sending a message normally, and you can adapt that to your own code. Again the first thing we need to do if we havent already is import discord.py so we can access the AllowedMentions class:\nimport discord from discord.ext import commands Now, I'll assume that we're in a cogso I can create a command like this:\n@commands.command(name=\u0026#34;dontpingme\u0026#34;) async def dont_ping_me(self, ctx: commands.Context): am = discord.AllowedMentions( users=False, ) await ctx.send(f\u0026#34;Hello, {ctx.author.mention}\u0026#34;, allowed_mentions=am) This example only disabled the users mention, since it's the only one that will happen, which means now you can run that command and the bot will mention you, but won't ping you. Neat, huh?\nNote that when using allowed mentions in a message specifically, any mentions you have set in the AllowedMentions object will override those mentions' settings that were set in the bot's constructor.  ","link":"https://tutorial.vcokltfre.dev/tips/mentions/","title":"Allowed Mentions"},{"body":"What is async? In Python we have a library called asyncio which allows the running of multiple tasks and coroutines simultaneously (or at least, the appearance of being simultaneous, but that's outside of the scope of this tutorial). Where traditionally you can only run one piece of code at a time, asyncio makes it so that you can have multiple running at once, and uses context switching to jump between the currently in-progress functions.\nThere are a ton of great PyCon talks about asyncio, notably this talk by David Beazley which explains amazingly well how a coroutine works at its heart. I highly recommend watching this video for a better understanding of the internals of how async works in Python.\nWhy is synchronous code an issue? Synchronous code is a problem in discord.py bots because it blocks the execution of the event loop while the blocking code executes. But why is that such a big issue? Because the websocket connection to Discord is also handled by the event loop. This means if you block the event loop for long enough then discord.py can't receive events from the gateway, or worse, and possibly fatally, it can't send heartbeats to the gatway, which after long enough will cause the gateway to kill the bot's connection to it.\nTechnically speaking, all code is blocking, some just blocks for less time than others. I say this so that someone doesn't bring this up in the repo issues, because it's out of scope for this tutorial, but if you're interested please do check out the video I linked above about async.  What can I do about this? Put simply: don't use blocking code. If you have loops of long running code, for example, you can add an await asyncio.sleep(0) on each loop. This yields control back to the event loop to allow other coroutines to execute. Explicitly using await is basically telling the event loop \u0026quot;hey, you've got control back to schedule other coroutines and tasks now\u0026quot;, allowing everything to work in parallel.\nYou should also seek to use async libraries for things such as http requests and database calls.\nAsync libraries Here's a table of async libraries you can use. If you have one to add, please make an issue or pull request on the repo.\n   Name Purpose     aiohttp Make async HTTP requests and WebSocket connections. This is the library that discord.py uses internally.   httpx Another async HTTP library.   asyncpg An async PostgreSQL database client.   aiomysql An async MySQL/MariaDB database client.   aiosqlite An async wrapper around sqlite3.   aiodns Async DNS requests so DNS resolution doesn't slow down the event loop.   uvloop Speed up the event loop using libuv bindings (except on Windows).    ","link":"https://tutorial.vcokltfre.dev/tips/blocking/","title":"Blocking Calls"},{"body":" I often see a lot of people using the wrong one, so here's a guide for which you should use.\ndiscord.Client The Client class is made specifically to connect to the gateway and handle API requests. As such it's not suitable for the majority of bot applications, and using commands.Bot is preferable since it will handle command parsing, permssion checks, etc for you.\ndiscord.ext.commands.Bot The Bot class is designed specifically for you to create functional bots with. It has far more features than the Client class alone, such as commands, cogs, permissions checks, cooldowns, custom checks you can create, command error handling, and more. Generally speaking you should be using this not client, there are very very few occasions you need to use client.\nFeature Comparison    Client Bot     Connects to the gateway Connects to the gateway   Handles API calls, obeying ratelimits Handles API calls, obeying ratelimits   Can handle individual events, i.e. message_create Can handle individual events, i.e. message_create   Can automatically shard Can automatically shard   - Can handle user defined commands   - Can put events and commands in separate files using cogs   - Can do built-in permission checks on commands   - Can create custom checks for commands   - Can have easy error handlers for commands   - Can create cooldowns for commands     A Note About Naming If you are using discord.Client you should name that variable client, likewise, if you are using commands.Bot you should name that variable bot. If you stick to naming things like this it will help you and other people understand your code, and make it easier for people to help if something breaks. Good naming matters. Readability counts. Please name your variables correctly, naming a Bot client is akin to creating a variable called integer and setting it to a string.\nCorrect:\nbot = commands.Bot(command_prefix=\u0026#34;!\u0026#34;) Incorrect:\nclient = commands.Bot(command_prefix=\u0026#34;!\u0026#34;) ","link":"https://tutorial.vcokltfre.dev/tips/clientbot/","title":"Client vs Bot"},{"body":"Tips:  Tips - Allowed Mentions Tips - Blocking Calls Tips - Client vs Bot Tips - Cogs vs Main Tips - Gateway Intents Tips - Storing Data Tips - Tokens  ","link":"https://tutorial.vcokltfre.dev/tips/","title":"discord.py tips"},{"body":" Intents are an important part of Discord which I briefly cover in this tutorial part, but which deserve their own section explaining them in more depth, so here it is!\n1 - What are Gateway Intents? Gateway intents are a way of getting only the data your application needs from the Discord gateway. When you first identify with the gateway upon starting your bot you send the intents you are going to use as an integer which represents a field of bits that describe which intents you need.\nThere are a few different gateway intents that you can select:\n   Gateway Intent Name in Docs Bit Shift Description Privileged     GUILDS 1 \u0026lt;\u0026lt; 0 Allows you to receive guild events like joining/leaving guilds, role events, and channel events. No   GUILD_MEMBERS 1 \u0026lt;\u0026lt; 1 Allows you to receive member events like joins and leaves. Yes   GUILD_BANS 1 \u0026lt;\u0026lt; 2 Allowd you to receive ban add and remove events. No   GUILD_EMOJIS 1 \u0026lt;\u0026lt; 3 Allows you to receive emoji updates. No   GUILD_INTEGRATIONS 1 \u0026lt;\u0026lt; 4 Allows you to receive integration update events. No   GUILD_WEBHOOKS 1 \u0026lt;\u0026lt; 5 Allows you to receive webhook update events. No   GUILD_INVITES 1 \u0026lt;\u0026lt; 6 Allows you to receive invite create and delete events. No   GUILD_VOICE_STATES 1 \u0026lt;\u0026lt; 7 Allows you to receive voice state update events. No   GUILD_PRESENCES 1 \u0026lt;\u0026lt; 8 Allows you to receive members' presence updates. Yes   GUILD_MESSAGES 1 \u0026lt;\u0026lt; 9 Allows you to receive message events like create and delete from guilds. No   GUILD_MESSAGE_REACTIONS 1 \u0026lt;\u0026lt; 10 Allows you to receive message reaction events like add and remove on guild messages. No   GUILD_MESSAGE_TYPING 1 \u0026lt;\u0026lt; 11 Allows you to receive typing events in guilds. No   DIRECT_MESSAGES 1 \u0026lt;\u0026lt; 12 Allows you to receive message events like create and delete from DMs. No   DIRECT_MESSAGE_REACTIONS 1 \u0026lt;\u0026lt; 13 Allows you to receive message reaction events like add and remove on DM messages. No   DIRECT_MESSAGE_TYPING 1 \u0026lt;\u0026lt; 14 Allows you to receive typing events in DMs. No    Bear in mind that these intents often also determine which data you receive upon connecting to the gateway. For example if you have members intents disabled you will not receive guild member lists upon connecting, in addition to not receiving member events.  Enabling Privileged Intents To enable privileged intents for your application, first head over to the Discord developer portal and click on your application. Next, head to the Bot tab on the left, and scroll down to the privileged intents section:\nBeyond 100 servers you bot will need to be verified and whitelisted for these intents to be able to use them.  Now you can select either or both of these intents so that you can use them in your code. Bear in mind that if one of these intents is not enabled on this page you cannot use it when connecting to the gateway.\nUsing Intents in Your Bot Let's start out with a simple bot setup:\nfrom discord.ext import commands bot = commands.Bot(command_prefix=\u0026#34;!\u0026#34;) This example has most of the intents enabled, all except members and presences. There are a couple of ways we can enable these intents, the first option being using all intents - which you should only use if you actually use both memebrs and presence intents:\nfrom discord.ext import commands from discord import Intents bot = commands.Bot(command_prefix=\u0026#34;!\u0026#34;, intents=Intents.all())  You shouldn't use all intents like this unless you actually use them!  The next method is to create a default intents object, and explicitly enable an intent on it, in this example I'll enabled the members intent since this is the most common one to need:\nfrom discord.ext import commands from discord import Intents intents = Intents.default() intents.members = True bot = commands.Bot(command_prefix=\u0026#34;!\u0026#34;, intents=intents) That's pretty much it for gateway intents, they're not too complicated but can definitely catch you out if you don't know about them, so watch out for where you might need to change them!\n","link":"https://tutorial.vcokltfre.dev/tips/intents/","title":"Gateway Intents"},{"body":" As your bot grows in features you'll probably want to store persistent data, and it's important to do this in the correct way, else you can make your life developing harder, and possibly compromise the functionality of your bot.\nIf you have one takeaway from this, let it be that JSON is not a database, and does not work as one, nor does CSV, or plain text files. JSON works well as a data transfer format, or for config files, but is not made for storing changeable persistent data.\nIn addition to this, spreadsheets are not databases either. Neither Excel nor Google Sheets are acceptable replacements for actual databases. If I hear that you, the reader, is using a spreadhseet as a database I will feel very bad please do not do this!\n Databases You Can Use Note that the following libraries are async libraries. discord.py is an async library too, so the libraries you use inside it should also be async to prevent blocking calls from stopping the event loop doing important things, such as heartbeating to the Discord gateway.  PostgreSQL Postgres is a popular SQL database due to its large feature set and efficiency, and is generally a good choice when storing data in a bot.\nTo use postgres in your bot you'll want to use a client library such as asyncpg which provides an easy interface for interacting with Postgres.\nMySQL / MariaDB MySQL or it's younger sibling MariaDB are also popular SQL databases which are also extremely commonly used. For most bots there will be no noticable difference between MySQL-based and Postgres, so it's really up to personal preference\nTo use MySQL or MariaDB in your bot you'll want the aiomysql client library, which also provides an easy interface for interacting with MySQL.\naiosqlite SQLite is a simple, fast, local database. It's a SQL database and can be easily used just about anywhere. It has similar use cases to the databases listed above. To use aiosqlite in your own bot you'll need the aiosqlite package installed.\nMongoDB MongoDB is a document store, not a relational database like MySQL or PostgreSQL, which means its usecases are slightly different. MongoDB is primarily for storing JSON-like objects but in a proper database so you don't need to handle file storage and other general shenanigans when storing data.\nTo use MongoDB in your bot you'll want to use the motor client library. Motor also provides an easy interface for interacting with MongoDB, but in a very different way to the previous SQL databases mentioned, since it's fundamentally a different kind of database.\nResources    Resource Description     asyncpg docs The official asyncpg documentation   aiomysql docs The official aiomysql documentation   aiosqlite docs The official aiosqlite documentation.   motor docs The official motor documentation   PostgreSQL tutorial A tutorial to help you learn how to use Postgres   MySQL tutorial A tutorial to help you learn how to use MySQL and MariaDB    ","link":"https://tutorial.vcokltfre.dev/tips/storage/","title":"Storing Data"},{"body":"In this bonus section I'll explain the 3 most common methods of storing credentials and tokens, while this is focused on discord.py everything after this paragraph applies generally to any secret you want to store. Note that for these examples you should assume that there is a bot defined somewhere else in the code, and the line bot.run(token) is at the bottom. I won't show the bot code in each example to show just the necessary information, and make this applicable outside of Discord bots too.\nYou should also be sure when using git to gitignore all of the files you store sensitive information in from any of these examples, to avoide committing them to version control.  .env files and the python-dotenv module One of the most standard methods in programming of storing your secret static data is in .env files, and this is used for far more than just Discord bots. To store your token in a .env file is quite simple.\nFirstly, you need a file named just .env which you can use to store the token. This file should look like the following:\nTOKEN=\u0026#39;your_token_here\u0026#39; That's all there is to the file, but to access it in python we need to do a bit more work. First, we need to install the python-dotenv package using pip install python-dotenv (or likely pip3 if you're on Linux) which will install the module. Now we need to import the module and actually load the file:\nfrom dotenv import load_dotenv load_dotenv() # You can pass the location of the .env file if it\u0026#39;s not in a standard location Now that we've imported the module and loaded the file, we need to access the token from it. To do this we need to import the os module so that we can access the environment variables:\nfrom dotenv import load_dotenv from os import getenv load_dotenv() token = getenv(\u0026#34;TOKEN\u0026#34;) That's it! The token is now loaded and ready to use.\nImporting from python files Another technique you can use is to import the token from a python file. This is far simpler than loading from a .env file as it requires no external modules and is just a regular python import.\nAssuming you have a folder named private and in it a file called config.py, you can simply use the following code to import the token from it:\nfrom private.config import token Which assumes config.py looks like this:\ntoken = \u0026#34;abcd_my_token\u0026#34; YAML and JSON config files The last common technique is using YAML and JSON files to store your token. First, I'll assume you have either a config.yml or config.json file. You're free to use whichever of these two you like, just look at the correct section for your type.\nYAML First, the file (config.yml) should look like the folowing:\ntoken:\u0026#34;abcd_my_token\u0026#34;Next, you'll need to have the pyyaml module installed, which can be installed using pip install pyyaml (or likely pip3 if you're on Linux) which will install the module. Now we need to import and load the data from that file:\nfrom yaml import safe_load from pathlib import Path with Path(\u0026#34;config.yml\u0026#34;).open() as f: config = safe_load(f) token = config[\u0026#34;token\u0026#34;] JSON For JSON it's more simple than YAML since no non-standard modules are needed, simply create a file (config.json) like the following:\n{ \u0026#34;token\u0026#34;:\u0026#34;abcd_my_token\u0026#34; } Next, we just need to load that token:\nfrom json import load from pathlib import Path with Path(\u0026#34;config.json\u0026#34;).open() as f: config = load(f) token = config[\u0026#34;token\u0026#34;] Which to choose Generally it's up to you which to choose for your project. Each has it's advantages and disadvantages.\n.env:    Advantages Disadvantages     Supported widely, including by things like Docker/docker-compose. Limited available data types.   No changes needed when setting the environment variable otherwise. Requires an additonal module not in the standard library.    Author's note: I actually can't think of more than this for .env, personally I dislike using .env files, but if you have anything else to put here please open an issue. config.py    Advantages Disadvantages     Easy to import from without any other modules. Less parsable if other programs need to access the data which aren't in python.   More complex data structures and being able to use python objects and operations.     config.json \u0026amp; config.yml    Advantages Disadvantages     Generally more complex data structures than .env. Not as complex as python structures can be.   Easy to group data, such as perhaps database credentials. Requires an additional module not in the standard library for YAML.    ","link":"https://tutorial.vcokltfre.dev/tips/tokens/","title":"Tokens"},{"body":" Cogs are a very important part of discord.py, which are discussed in this tutorial part, but that's more of a guide starting from the start, rather than showing how to transfer an existing bot to use cogs, so that's what this bonus part is for!\nI'll be using typehinting (e.g def foo(bar: Baz):) throughout this part. Not doing so will not cause any difference to the bot, however it will make it so that there are far less useful code suggestions from your IDE, so generally I'd recommend using it where possible.  Firstly, here's a simple bot which I'll be transitioning to cogs:\nfrom discord.ext import commands from discord import Message from dotenv import load_dotenv from os import getenv load_dotenv() # To learn more about this visit https://vcokltfre.dev/tips/tokens/ bot = commands.Bot(command_prefix=\u0026#34;!\u0026#34;) @bot.event async def on_message(message: Message): if message.author.bot: return if \u0026#34;hello\u0026#34; in message.content.lower(): # A simple example, don\u0026#39;t want to get too complex await message.channel.send(\u0026#34;Hi!\u0026#34;) await bot.process_commands(message) @bot.command(name=\u0026#34;ping\u0026#34;) async def ping(ctx: commands.Context): \u0026#34;\u0026#34;\u0026#34;Show the bot\u0026#39;s gateway latency.\u0026#34;\u0026#34;\u0026#34; await ctx.send(f\u0026#34;Pong! {round(bot.latency * 1000)}ms\u0026#34;) bot.run(getenv(\u0026#34;TOKEN\u0026#34;))  In case you didn't know, it's very important here in the on_message event that we use bot.process_commands afterwards, that way we can still handle commands, else no commands will be handled at all. This not an issue when using @bot.listen() rather than @bot.event, or when using cogs.  Beyond this point you will need at least a basic understanding of Object Oriented Programming (OOP)/classes in Python. If you're not familiar with this, check out the first video in Corey Schafer's OOP Tutorial.  Next, we can move on to actually creating the cog itself, which we are going to do in a different file called mycog.py:\nfrom discord.ext import commands class MyCog(commands.Cog): # All cogs must inherit from commands.Cog \u0026#34;\u0026#34;\u0026#34;A simple, basic cog.\u0026#34;\u0026#34;\u0026#34; def __init__(self, bot: commands.Bot): self.bot = bot def setup(bot: commands.Bot): bot.add_cog(MyCog(bot)) The first important thing to note here is that when creating the class we have a bot argment in the cog's constructor. This means that we can have cogs in other files without needing to somehow import and reference the bot from the main file.\nNext, there's the setup function. This is what discord.py looks out for when trying to load the cog. It must be called setup else the cog will fail to load and you'll get an error.\nNow that we have a simple cog we can add in out existing listener and commmand to it:\nfrom discord.ext import commands from discord import Message class MyCog(commands.Cog): # All cogs must inherit from commands.Cog \u0026#34;\u0026#34;\u0026#34;A simple, basic cog.\u0026#34;\u0026#34;\u0026#34; def __init__(self, bot: commands.Bot): self.bot = bot @commands.Cog.listener() async def on_message(self, message: Message): if message.author.bot: return if \u0026#34;hello\u0026#34; in message.content.lower(): await message.channel.send(\u0026#34;Hi!\u0026#34;) @commands.command(name=\u0026#34;ping\u0026#34;) async def ping(self, ctx: commands.Context): \u0026#34;\u0026#34;\u0026#34;Show the bot\u0026#39;s gateway latency.\u0026#34;\u0026#34;\u0026#34; await ctx.send(f\u0026#34;Pong! {round(self.bot.latency * 1000)}ms\u0026#34;) def setup(bot: commands.Bot): bot.add_cog(MyCog(bot)) There are several key changes here that need to be noted:\n We're now passing self as the first argument to each function, this is because we're inside a class now. We no longer need to call process_commands in the on_message listener, since now it's a listener rather than an event. When getting the bot's latency we now use self.bot.latency, again because we're now inside a class.  Ok great! We have a cog, now we need to load this cog in the main file. I've stripped the event and command out, since they're not in the cog, so here's what we're left with:\nfrom discord.ext import commands from discord import Message from dotenv import load_dotenv from os import getenv load_dotenv() bot = commands.Bot(command_prefix=\u0026#34;!\u0026#34;) bot.run(getenv(\u0026#34;TOKEN\u0026#34;)) Now, we need to add just a single line of code to load that cog we just made:\nfrom discord.ext import commands from discord import Message from dotenv import load_dotenv from os import getenv load_dotenv() bot = commands.Bot(command_prefix=\u0026#34;!\u0026#34;) bot.load_extension(\u0026#34;mycog\u0026#34;) # \u0026lt;--- This single line of code to be precise bot.run(getenv(\u0026#34;TOKEN\u0026#34;))  It's highly recommended that you include some error handling around cog loading, but how that's implemented is up to you. It may also be useful to have a list of cogs and iterate over them and call load_extension so that you don't repeat yourself.  load_extension works in a similar way to import. For example let's say we have the following directory structure:\n/ bot.py /cogs mycog.py /utils prefix.py We can load mycog from bot.py by using load_extension(\u0026quot;cogs.mycog\u0026quot;)\nThere's a lot more you can do with cogs too, such as reloading cogs, or running code on cog load, unload, and reload. For a more comprehensive list of things cogs can do you should see the discord.py docs page on cogs.\n ","link":"https://tutorial.vcokltfre.dev/tips/cogs/","title":"Transitioning to Cogs"},{"body":"There are several of ways you can go about error handling with discord.py:\n Per-command error handlers Per-cog error handlers Global error handlers  In this part I will only be covering per-command and global error handlers, but by all means feel free to go down the per-cog route by reading the docs and experimenting on your own. Again, as a general reminder I advise you don't just copy the code here, rather try to understand it yourself and make your own code. You don't learn by copying, you learn by doing.\nPer-command Error Handling Okay! The first type of handler we'll make is a simple one for a single command. First let's get the basic code for a cog and a basic command:\nfrom discord.ext import commands from discord import Member class ExampleCog(commands.Cog): \u0026#34;\u0026#34;\u0026#34;An example cog to show error handling.\u0026#34;\u0026#34;\u0026#34; def __init__(self, bot: commands.Bot): self.bot = bot @commands.command(name=\u0026#34;example\u0026#34;) @commands.cooldown(rate=1, per=5, type=commands.BucketType.member) @commands.has_guild_permissions(manage_messages=True) async def example(self, ctx: commands.Context, member: Member): \u0026#34;\u0026#34;\u0026#34;An example command to show error handling.\u0026#34;\u0026#34;\u0026#34; await ctx.send(f\u0026#34;{1/0}\u0026#34;) def setup(bot: commands.Bot): bot.add_cog(ExampleCog(bot)) You may have noticed the command doesn't do very much - in fact all it does is raise a DivisionByZero error as soon as it runs, but for our purpose this is useful. There are a few different types of error that can be raised here:\n CommandOnCooldown due to the cooldown decorator MissingPermissions due to the has_guild_permissions decorator MissingRequiredArgument due to member being required ConversionError due to the Member typehint on member CommandInvokeError due to the content of the command raising DivisionByZero  To get the original error from a CommandInvokeError, you can use its original attribute, which returns the exception that cause it.  Now, on to the error handler itself. The first thing we need to do to add the error handler is to tell discord.py we want to add an error handler to the command, which we can do by using the command's error decorator:\n# Assume that this is all between the command definition and the setup function. @example.error # Replace `example` with whatever the function name of the command is. This tells discord.py to add the function the decorator decorates as the error handler for the command, and it will be called if any error is raised during the command execution, or indeed pre-invokation if the check functions or conversion fails.\nNext, we need to actually add a function that will handle the error:\n@example.error async def example_error(self, ctx: commands.Context, error: commands.CommandError): \u0026#34;\u0026#34;\u0026#34;Handle errors for the example command.\u0026#34;\u0026#34;\u0026#34; Great! As you can see the function takes 2 non-self arguments: ctx and error, which are the command context and the error which was raised. Now, let's add some logic in to the function to show the relevant information to the user so they know what's gone wrong, as usual I'll explain what everything does after, and I urge you don't copy this code but understand it and work on writing your own handler.\n@example.error async def example_error(self, ctx: commands.Context, error: commands.CommandError): \u0026#34;\u0026#34;\u0026#34;Handle errors for the example command.\u0026#34;\u0026#34;\u0026#34; if isinstance(error, commands.CommandOnCooldown): message = f\u0026#34;This command is on cooldown. Please try again after {round(error.retry_after, 1)}seconds.\u0026#34; elif isinstance(error, commands.MissingPermissions): message = \u0026#34;You are missing the required permissions to run this command!\u0026#34; elif isinstance(error, commands.MissingRequiredArgument): message = f\u0026#34;Missing a required argument: {error.param}\u0026#34; elif isinstance(error, commands.ConversionError): message = str(error) else: message = \u0026#34;Oh no! Something went wrong while running the command!\u0026#34; await ctx.send(message, delete_after=5) await ctx.message.delete(delay=5) That's a lot of code, but here's what each part of it does:\n First, isinstance is a python method that checks whether an object is an instance of a given class. In this case we're checking whether the error is an instance of various discord.py errors to determine which error message we want to send, as sometimes they have different parameters. The first error is CommandOnCooldown. Here we want to send how long in seconds until the cooldown is over and the user can use the command again, which we can get by the error's retry_after attribute. Next, for MissingPermissions we just want to send that the user is missing the required permissions. It's also possible to send exactly which permission they lack, but for simplicity I'm going to leave that out here, since by default it uses internal names like manage_guild, rather than pretty Discord names like Manage Server For MissingRequiredArgument we want to show which argument is missing using the error's param attribute. Now, if the error is none of those, we want to send a generic message saying that the command failed, and we send that message with the delete_after parameter so that the message deletes itself after 5 seconds. Finally, we want the message that caused the error to be deleted too, so we can keep chat clean. We don't want this to be deleted immediately, so we set it to be deleted after a delay of 5 seconds, which means the command and error response will be deleted at roughly the same time.  That's essentially it for per-command handlers, of course there are other types of error that can be raised in other circumstances, and I'd highly recommend reading the discord.py docs on exceptions to find out more info about them.\nGlobal Error Handling Okay, per-command handling done, on to global handling! Note that some of the content here does assume that you have read the section on per-command handling, so I'd recommend reading that bit if you haven't so you have the required context, even if you don't intend on using a per-command handler.\nThe first thing we're going to want to do, as with per-command handling, is create a cog, only this time we won't be putting any commands in it, it will be reserved for just errors. This is not necessary, but it does help to segment your code and keep everything easy to find and separate, which is nice and clean.\nfrom discord.ext import commands class ErrorHandler(commands.Cog): \u0026#34;\u0026#34;\u0026#34;A cog for global error handling.\u0026#34;\u0026#34;\u0026#34; def __init__(self, bot: commands.Bot): self.bot = bot def setup(bot: commands.Bot): bot.add_cog(ErrorHandler(bot)) Pretty simple, that's essentially just the standard template for a cog as normal. Next we're going to add a listener to receive the command errors:\n# Assume this is all between the class\u0026#39; constructor and the setup method. @commands.Cog.listener() async def on_command_error(self, ctx: commands.Context, error: commands.CommandError): \u0026#34;\u0026#34;\u0026#34;A global error handler cog.\u0026#34;\u0026#34;\u0026#34; The parameters are exactly the same as a command error, but this time instead of using a decorator from a command, we're using a listener, on_command_error. As with the per-command error handler we now want to do logic to determine what message to send the user:\nThis is not a complete error handler. There are exceptions missing, and I do not intend to include them. This is to dissuade people from simply copying the error handler for themselves. I can't stress enough how important it is for learning that people try things for themselves rather than copying code. For all of the errors you might need to handle here, I advise reading the discord.py docs on exceptions. In addition, some of the errors here have multiple derived exceptions, such as UserInputError, by all means make more specific error handlers which have specialised messages for each exception!  @commands.Cog.listener() async def on_command_error(self, ctx: commands.Context, error: commands.CommandError): \u0026#34;\u0026#34;\u0026#34;A global error handler cog.\u0026#34;\u0026#34;\u0026#34; if isinstance(error, commands.CommandNotFound): return # Return because we don\u0026#39;t want to show an error for every command not found elif isinstance(error, commands.CommandOnCooldown): message = f\u0026#34;This command is on cooldown. Please try again after {round(error.retry_after, 1)}seconds.\u0026#34; elif isinstance(error, commands.MissingPermissions): message = \u0026#34;You are missing the required permissions to run this command!\u0026#34; elif isinstance(error, commands.UserInputError): message = \u0026#34;Something about your input was wrong, please check your input and try again!\u0026#34; else: message = \u0026#34;Oh no! Something went wrong while running the command!\u0026#34; await ctx.send(message, delete_after=5) await ctx.message.delete(delay=5) As you can see, this isn't massively different from the per-command handler, but there are a couple of notable differences:\n We're using a listener for the event, rather than assigning a handler to a specific command. There's a possibility we now get CommandNotFound errors, so we deal with them (by ignoring them because it get's pretty spammy!) In general we're handling the errors in a more generic way, we don't know exactly which exceptions could be raised anymore, so we need to account for that.  Again, there are far, far more errors than this, and doing some fancy error embeds might look nice too, but I'll leave that as an exercise for the reader, for this part is now complete! (p.s. for the embed thing, perhaps try making something like you see below!)\nLooks like you're now ready to move on to the next part: permissions!\nNext: Permissions ","link":"https://tutorial.vcokltfre.dev/tutorial/12-errors/","title":"12 - Error Handling"},{"body":"Fortunately for us, discord.py provides built-in cooldown decorators that we can use on our existing commands that do just this. This will be a fairly small part, since there is not that much to cover on the topic, however I hope it will be of great use for ratelimiting your commands.\nTo start with, let's recap one of the commands we have from earlier, the setstatus command:\n@commands.command(name=\u0026#34;setstatus\u0026#34;) async def setstatus(self, ctx: commands.Context, *, text: str): \u0026#34;\u0026#34;\u0026#34;Set the bot\u0026#39;s status.\u0026#34;\u0026#34;\u0026#34; await self.bot.change_presence(activity=discord.Game(name=text)) Now, we don't want someone seeing this in chat and deciding that they want to keep testing it over and over, that would be spammy and unwanted. So, we put a cooldown on the command. Cooldowns use decorators, just like how you defined that it was a command, as a few other things do also, which I'll show later in the tutorial. If we add a cooldown the command will end up looking like this:\n@commands.command(name=\u0026#34;setstatus\u0026#34;) @commands.cooldown(rate=1, per=30) async def setstatus(self, ctx: commands.Context, *, text: str): \u0026#34;\u0026#34;\u0026#34;Set the bot\u0026#39;s status.\u0026#34;\u0026#34;\u0026#34; await self.bot.change_presence(activity=discord.Game(name=text)) As you can see, we added the line @commands.cooldown(rate=1, per=30), which limits the command to be run once every 30 seconds globally (across all servers the bot is in).\nBy default the cooldown decorator uses commands.BucketType.default as it's bucket type - which is a global bucket. This means if I use !setstatus in my server, and Dave uses !setstatus in his server two seconds later, the command won't work for him, because the cooldown is global. Due to the global nature of the !setstatus command (the status can be seen globally, after all), I'll continue to use the global cooldown bucket, but you can use any of these bucket types.  Make note of the fact that BucketType.user and BucketType.member are different things. User will create a global cooldown for a single user across all servers the bot is in, whereas member is per guild.  Now we have an issue, if we run the command in rapid succession nothing happens - not even showing an error to the user. This can leave people fairly confused, \u0026quot;It worked for vco, why didn't it work for me?\u0026quot; which is why we now need to add error handling for it. Error handling will also be covered in far greater detail later in the tutorial, but for the purposes of this part, I'll add a simple one for the command. Adding an error handler for a command looks something like the following:\n@setstatus.error async def setstatus_error(self, ctx: commands.Context, error): if isinstance(error, commands.CommandOnCooldown): await ctx.send(f\u0026#34;This command is on cooldown, try again after {round(error.retry_after)}seconds.\u0026#34;, delete_after=5) print(error) I won't go over the error handling in detail here, but there is one new thing here I should mention. If you look in the ctx.send() function, you'll see a delete_after parameter, this tells discord.py to delete the message after the interval provided, so the error message gets deleted after a few seconds and doesn't clog up chat.\nThat's it for cooldowns, there isn't much more to know (though I suggest you check the docs page for them), you're now ready to move onto the next part, error handling!\nNext: Error Handling ","link":"https://tutorial.vcokltfre.dev/tutorial/11-cooldowns/","title":"11 - Cooldowns"},{"body":"I won't show the embeds in tandem with the actual bot, since we're focusing on creating them, but to send them you can use the method presented in 09 - What Did That Message Say?\nFor this part I'll assume that you have imported discord at the top of your file.\nCreating an Embed Creating an embed is a simple as instantiating an Embed object like this:\nembed = discord.Embed() But that is not a very useful (although still valid) embed, since it's empty. To make it useful we need to add content to the embed. The first way we can do this is with the title attribute:\nembed = discord.Embed(title=\u0026#34;Hello, world!\u0026#34;) Which will create an embed that looks like this:\nBut that's not a very interesting embed, there isn't much to it and it doesn't really display anything useful. One way we can add more to it is by adding a description:\nembed = discord.Embed(title=\u0026#34;Hello, world!\u0026#34;, description=\u0026#34;:D\u0026#34;) Which will create the following embed:\nIt still feels like it's missing something important though... Ah yes! Colour! We can give an embed a colour by specifying the colour keyword argument, which is an integer (which I'll represent in hexadecimal for readability), or you can pass it a discord.py colour. For this example I'll use sky blue, 0x87CEEB, as it's a nice colour and quite possibly matches the colour of my logo:\nembed = discord.Embed(title=\u0026#34;Hello, world!\u0026#34;, description=\u0026#34;:D\u0026#34;, colour=0x87CEEB) Which means we now have an embed that looks like this:\nHmmm... Better, but it still needs more... Let's give it a username and icon:\nembed = discord.Embed(title=\u0026#34;Hello, world!\u0026#34;, description=\u0026#34;:D\u0026#34;, colour=0x87CEEB) embed.set_author(name=\u0026#34;vcokltfre\u0026#34;, icon_url=\u0026#34;https://avatars.githubusercontent.com/u/16879430\u0026#34;)  You can also pass GIFs as parameters for image fields like avatar and thumbnail on embeds.  There we go, it's starting to look much nicer and more informative and full now, isn't it?\nBut there's still more that we can do! Embeds have a whole lot to offer to make an otherwise bland text chat more rich. Let's add some fields to show information. In this example it will be static information, but you can always replace it with dynamic content (think bot ping perhaps? I'll leave that as an exercise to the reader.)\nembed = discord.Embed(title=\u0026#34;Hello, world!\u0026#34;, description=\u0026#34;:D\u0026#34;, colour=0x87CEEB) embed.set_author(name=\u0026#34;vcokltfre\u0026#34;, icon_url=\u0026#34;https://avatars.githubusercontent.com/u/16879430\u0026#34;) embed.add_field(name=\u0026#34;Field 1\u0026#34;, value=\u0026#34;Not an inline field!\u0026#34;, inline=False) embed.add_field(name=\u0026#34;Field 2\u0026#34;, value=\u0026#34;An inline field!\u0026#34;, inline=True) embed.add_field(name=\u0026#34;Field 3\u0026#34;, value=\u0026#34;Look I\u0026#39;m inline with field 2!\u0026#34;, inline=True) As you can see, now we're able to make far more detailed embeds like this:\nAnd embeds still have more to offer, so for the sake of not making this part as long as a novel let's add a few now at the same time (we will need to import the datetime module for this due to the timestamp requiring it):\nfrom datetime import datetime embed = discord.Embed(title=\u0026#34;Hello, world!\u0026#34;, description=\u0026#34;:D\u0026#34;, colour=0x87CEEB, timestamp=datetime.utcnow()) embed.set_author(name=\u0026#34;vcokltfre\u0026#34;, icon_url=\u0026#34;https://avatars.githubusercontent.com/u/16879430\u0026#34;) embed.add_field(name=\u0026#34;Field 1\u0026#34;, value=\u0026#34;Not an inline field!\u0026#34;, inline=False) embed.add_field(name=\u0026#34;Field 2\u0026#34;, value=\u0026#34;An inline field!\u0026#34;, inline=True) embed.add_field(name=\u0026#34;Field 3\u0026#34;, value=\u0026#34;Look I\u0026#39;m inline with field 2!\u0026#34;, inline=True) embed.set_footer(text=\u0026#34;Wow! A footer!\u0026#34;, icon_url=\u0026#34;https://cdn.discordapp.com/emojis/754736642761424986.png\u0026#34;) Remember that you need to send the embed to a channel too. This means you need to call send(embed=embed) on a messageable object, for example a TextChannel object (i.e. message.channel.send) or a Context object (ctx.send) or the embed will not be sent.\nThere are a few more things that haven't been covered here, but they're generally less commonly used, and if you want to learn more about them, I recommend you read the discord.py docs on embeds.\nNow that we're done with embeds, you can move on to the next part, Cooldowns!\nNext: Cooldowns ","link":"https://tutorial.vcokltfre.dev/tutorial/10-embeds/","title":"10 - All About Embeds"},{"body":"To do this I'll introduce a couple of new things we haven't met yet:\n The message delete event  and as such also what the message cache is   Embeds  The aim of this part is to teach you about how the on_message_delete event works, and creating an embed with the content of the deleted message to create a !snipe command.\nFirstly, we'll take the code from the previous parts. For this example I'll remove the current commands and events from somecommands.py so that we can focus on the main topic.\nWe will start out with the following code:\nimport discord from discord.ext import commands class SomeCommands(commands.Cog): \u0026#34;\u0026#34;\u0026#34;A couple of simple commands.\u0026#34;\u0026#34;\u0026#34; def __init__(self, bot: commands.Bot): self.bot = bot def setup(bot: commands.Bot): bot.add_cog(SomeCommands(bot)) Now that we have the base code there are a few things we need to add. Firstly we need to create an attribute of the cog that stores the last deleted message, which we'll set to None by default in the constructor:\ndef __init__(self, bot: commands.Bot): self.bot = bot self.last_msg = None Following this we can move onto creating a listener for the on_message_delete event so that we can record when messages are deleted:\n@commands.Cog.listener() async def on_message_delete(self, message: discord.Message): self.last_msg = message  Again, typehinting is not strictly needed here, however in my IDE (VSCode) it means I get more useful code suggestions, so in that regard it's very useful.  Here's where the message cache comes in; this event will only trigger if the message that got deleted is in the bot's internal message cache, which it will only be if that message was received by the bot during it's current session. By default the message cache stores 1,000 messages, but this can be changed in the bot's constructor with the max_messages keyword argument. Messages sent before the bot was started won't fire on_message_delete events when deleted, nor will they fire on_message_edit events. It is however possible to listen to the raw delete and edit events, which will give you the raw payload data sent by Discord, without using the internal cache.\nNext, we need to add a command that lets us access this message, and then create an embed and send it, but we also need to handle the case that no message has been deleted since the bot started. As normal I'll show the code we're using and explain the new parts afterwards:\n@commands.command(name=\u0026#34;snipe\u0026#34;) async def snipe(self, ctx: commands.Context): \u0026#34;\u0026#34;\u0026#34;A command to snipe delete messages.\u0026#34;\u0026#34;\u0026#34; if not self.last_msg: # on_message_delete hasn\u0026#39;t been triggered since the bot started await ctx.send(\u0026#34;There is no message to snipe!\u0026#34;) return author = self.last_msg.author content = self.last_msg.content embed = discord.Embed(title=f\u0026#34;Message from {author}\u0026#34;, description=content) await ctx.send(embed=embed) There's quite a lot to cover for this command, so we'll start at the beginning. First we check whether there is a last_message, if not we send a message saying so, and then return from the function so the rest of it doesnt execute.\nNext, we set a variable called content to the content of the message that was deleted, and author to the author of the deleted message. We could do this inline in the embed's constructor, but I've chosen not to here so that we dont have huge lines, but the functionality remains the same.\nNow, we create the embed itself. We want to give it the title of who deleted the message, so we use an f-string to put that in, and following that we set the description to the content variable we just made. That's about as simple as it gets for embeds, and in the next part I'll cover embeds in a lot more depth.\nFinally, we send embed to the channel. To do this we need to explicitly state that we want to send an embed with the embed keyword argument. If you test your bot now you should see something like this:\nAwesome! That's it for this part of the tutorial, you can now move on to part 10, All About Embeds!\nNext: All About Embeds ","link":"https://tutorial.vcokltfre.dev/tutorial/09-snipe/","title":"09 - What Did That Message Say?"},{"body":"To add API latency we're going to send a message, and time how long it takes to send, then we'll edit that message to show the ping. This will be quite a short part, as it is just a modification to the existing ping command. To recap, here's the existing ping command:\n@commands.command(name=\u0026#34;ping\u0026#34;) async def ping(self, ctx: commands.Context): \u0026#34;\u0026#34;\u0026#34;Get the bot\u0026#39;s current websocket latency.\u0026#34;\u0026#34;\u0026#34; await ctx.send(f\u0026#34;Pong! {round(self.bot.latency * 1000)}ms\u0026#34;) Firstly, we need to import the time module from the Python standard library. This means we can get the current UNIX time so that we can time the execution of sending the message, which will give us the API latency:\nimport time # Put this *at the top of the file* Now, I'll show the updated code, and then explain afterwards what was changed and why:\n@commands.command(name=\u0026#34;ping\u0026#34;) async def ping(self, ctx: commands.Context): \u0026#34;\u0026#34;\u0026#34;Get the bot\u0026#39;s current websocket and API latency.\u0026#34;\u0026#34;\u0026#34; start_time = time.time() message = await ctx.send(\u0026#34;Testing Ping...\u0026#34;) end_time = time.time() await message.edit(content=f\u0026#34;Pong! {round(self.bot.latency * 1000)}ms\\nAPI: {round((end_time - start_time) * 1000)}ms\u0026#34;) First, we set start_time to the current UNIX timestamp, then we send a message saying that we're testing ping, and then record the end_time. This is all fairly simple Python, or content we've covered earlier in the turorial, the main difference being that we store the message object returned by the API in the message variable.\nNow we see a new function we haven't used before, editing an existing message. Unlike sending a message, we need to specify that we're editing the content of the message. As with the previous ping command we show the websocket latency, but now we also show the latency to the API, calculated in much the same way.\nThat's it for this part of the tutorial, not a very long part but now you know how to edit messages, which can be quite useful. Now you can move on to the next part, What Did That Message Say?\nNext: What Did That Message Say? ","link":"https://tutorial.vcokltfre.dev/tutorial/08-ping2/","title":"08 - A Better Ping Command"},{"body":"To start out, we'll once again use the same code from the previous part and add to that. First, we have a modification we need to make to the bot.py file. Up until this point we've been using the default gateway intents that discord.py sends to the gateway - which is all except the privileged intents (server members and presences).\nBefore we can proceed to modify the code, we need to enable these privileged intents on the Discord developer portal. Go to your bot's bot page on the portal, and scroll down to the privileged intents section:\nBeyond 100 servers you bot will need to be verified and whitelisted for these intents to be able to use them.  Now, you need to enable the server members intent, and click save to update the application.\nIntents exist for a good reason - to reduce computational burden. On larger bots it may be an issue to have these intents enabled as it means Discord sends a lot more data to the bot, which may overwhelm it, although this should not be an issue for small or even fairly large bots.  Even without the server members intent enabled, Discord will sometimes still provide you with members, such as in messages, voice state updates, etc. This means that you can often use them as members in things like commands, and they will populate the member cache too. The main thing to note is that with members intent disabled, you will not initially be given the member list, you will not receive member updates such as joins/leaves/nickname changes, and you will not be able to fetch members from the API.  With that done, let's get back to the code - this will be the last time we have to visit the developer portal for a while. First, we need to tell discord.py to use these intents when connecting to the gateway, which we'll do by creating an intents object with the default intents, and enabling members intent, after which the bot file will look like this:\nimport discord from discord.ext import commands intents = discord.Intents.default() intents.members = True bot = commands.Bot(command_prefix=\u0026#34;!\u0026#34;, intents=intents) bot.load_extension(\u0026#34;somecommands\u0026#34;) bot.run(\u0026#34;your_token_here\u0026#34;)  This is a insecure way of setting the token used for brevity, please read this bonus part about storing tokens.  That's all that needed to enable intents, and now we can harness the full power of Discord gateway events! Now, we have to create the code that welcomes people, which we will stick in the somecommands.py for now, but you're free to make another file and another cog, and load it in the same way as before.\nAgain, this will be within the class, just under the commands we already have - but wait, this isn't a command, its an event. Luckily discord.py has us covered for events too, and provides listeners so that we can use them.\nAs with previous examples I'll show the code we need to use and then explain what the new bits do afterwards:\n@commands.Cog.listener() async def on_member_join(self, member: discord.Member): channel = self.bot.get_channel(799309066202775624) if not channel: return await channel.send(f\u0026#34;Welcome, {member}!\u0026#34;) Ok, quite a lot to cover with this one. First, we have a new decorator, commands.Cog.listener(). This is like commands.command(), only it now receives different gateway events rather than messages, in this case the member join event (a full list of events can be found here in the documentation) which gives us details about a member joining a guild.\nNext, we get a channel from the bot, this is the channel that we'll send the welcome message in. To do this we use self.bot.get_channel() to get a channel from the bot's cache of channels.\nNote that I explicitly use the word get here, not fetch. This is because in discord.py, and now throughout this tutorial, get will refer to fetching something from the local cache, and fetch will mean fetching something from the API. It's important to distinguish which is which, because the get methods are synchronous, while fetch methods are asynchronous and must be awaited.  Now, you'll likely have noticed the long number in there, that's the channel's unique snowflake ID. All objects in Discord, be it a role, channel, guild, user, etc. have an ID (excluding things like permission overwrites which just map user and role IDs to a set of permissions) which can be found in the client by right clicking the object and clicking copy ID. To have this option you need to have developer mode enabled. Make sure to replace my channel ID with one of your own, or the message won't be sent!\nNext, we need to check if we actually have a channel to send to, since it's not guaranteed, so we check if channel is truthy, and return if it isnt.\nFinally, we send a message to the channel which welcomes the user. In f-string expressions or when converting discord.py objects to strings in general, perhaps using str(), if the object has a name attribute that's what it will convert to. For members and users however it's slightly more, and it will convert to the username and discriminator, which is the four numbers after the #, so let's take my user object for example, if we do str(vcokltfre_user) we'll get 'vcokltfre#6868' - which in a welcome message is preferable to pinging people when they join, which can be quite annoying. It's also recommended that you dont DM people welcome messages either.\nIt's possible to mention the user without pinging them using a Discord feature called allowed mentions which discord.py has support for. If you would like to learn more about allowed mentions please read this bonus part.  If you do decide to have the bot DM people on join do be careful - Discord will disable and quarantine a bot's access to DMing people if it DMs members too quickly. This applies in general not just with welcome messages.  That's it for this part - your bot should now have a fully functioning welcome message when new people join the server. If it doesn't work be sure to check that you have used the correct channel ID for the channel you want to send it in, and that the ID is an integer, not a string.\nNow you're ready to move on to the next part!\nNext: A Better Ping Command ","link":"https://tutorial.vcokltfre.dev/tutorial/07-welcome/","title":"07 - Welcome"},{"body":"For this part we'll start off with the same files we ended with in the last part, which means we'll be adding our new command to somecommands.py, and in fact we won't even need to change the main bot file, that can stay just as it is.\nTo recap, here's the somecommands.py file from the last part:\nfrom discord.ext import commands # Again, we need this imported class SomeCommands(commands.Cog): \u0026#34;\u0026#34;\u0026#34;A couple of simple commands.\u0026#34;\u0026#34;\u0026#34; def __init__(self, bot: commands.Bot): self.bot = bot @commands.command(name=\u0026#34;ping\u0026#34;) async def ping(self, ctx: commands.Context): \u0026#34;\u0026#34;\u0026#34;Get the bot\u0026#39;s current websocket latency.\u0026#34;\u0026#34;\u0026#34; await ctx.send(f\u0026#34;Pong! {round(self.bot.latency * 1000)}ms\u0026#34;) # Now, we need to set up this cog somehow, and we do that by making a setup function: def setup(bot: commands.Bot): bot.add_cog(SomeCommands(bot)) To add the new status command we want to put it just after the ping command - inside the class. For this command we'll be introduced to a couple of new things. Firstly, we're going to need to import the main discord.py library to use a certain class from it, and second this command needs to take in text to set the status to.\nTo start with, you'll need to add this line to the top of your file to import the main discord.py library:\nimport discord Now you can add a new command under ping that lets you change the status, which will look like this (don't worry, I'll explain all the new stuff we see after the code):\n@commands.command(name=\u0026#34;setstatus\u0026#34;) async def setstatus(self, ctx: commands.Context, *, text: str): \u0026#34;\u0026#34;\u0026#34;Set the bot\u0026#39;s status.\u0026#34;\u0026#34;\u0026#34; await self.bot.change_presence(activity=discord.Game(name=text)) The first new thing here is this bit:\n, *, text: str This essentially takes all user input after the command and passes it as the text parameter. This is where it's useful to have the typehints I mentioned earlier, as it tells discord.py's converters which type to convert the arguments given into.\nNext, we have a change_presence function on the bot. In Discord a status is more broadly known as a presence and can include info such as Spotify statuses for non bot users. change_presence, as its name suggests, changes the bot's status to the value given. In this case we give it a discord.Game object whose name is whatever text we gave, which will make the status look like \u0026quot;Playing {text}\u0026quot;\nNote that in this function we dont use ctx, but it still needs to be part of the function defintion, as discord.py always passes it first in commands.  Now you should be able to test it out and see the bot set its status to something you type in, if you run a command like !setstatus Minecraft.\nAnd that's the end of part 6! Now you can move on to the next part - Welcome.\nNext: Welcome ","link":"https://tutorial.vcokltfre.dev/tutorial/06-online/","title":"06 - Online!"},{"body":"Cogs represent a fairly drastic change in the way you write commands and bots, so it's good that we're getting into them here before you're too used to sticking the commands in the main file of the bot.\nCogs require a basic understanding of OOP/classes in Python. If you're not familiar with this, check out the first video in Corey Schafer's OOP Tutorial.  To start out with cogs we're going to abandon the code from the previous sections largely in favour of new commands tailored to cogs. First, I'll show how to make a cog still in the main file of the bot, then I'll show you how to move it into a separate file completely.\nFirstly, as with the previous samples, we need to import the commands module of discord.py and create a bot:\nfrom discord.ext import commands bot = commands.Bot(command_prefix=\u0026#34;!\u0026#34;) Next, we need to create a class that inherites from commands.Cog that we can put our commands in, and a constructor that takes in the bot as its only argument and saves it (at this point I'll also start adding docstrings, those things between \u0026quot;\u0026quot;\u0026quot; \u0026quot;\u0026quot;\u0026quot;, that explain what cogs or commands are for, and are used in the built-in help command):\nclass SomeCommands(commands.Cog): \u0026#34;\u0026#34;\u0026#34;A couple of simple commands.\u0026#34;\u0026#34;\u0026#34; def __init__(self, bot: commands.Bot): self.bot = bot If you didn't know yet, bot: commands.Bot is known as typehinting, and it gives the IDE you're using (or sometimes discord.py itself) a hint as to what type the argument is. You'll see this come in handy later on when we add arguments of certain types to our commands.\nNow we want to add back the commands we had before. For the sake of simplicity, we wont add back the hello command, it was a good starting point but in reality commands with static output aren't that interesting, so we probably wont use them much more.\nIn cogs, commands have their own way of being defined, which is using the commands.command() decorator. It serves the same function as bot.command(), however it now works in cogs too:\n@commands.command(name=\u0026#34;ping\u0026#34;) async def ping(self, ctx: commands.Context): \u0026#34;\u0026#34;\u0026#34;Get the bot\u0026#39;s current websocket latency.\u0026#34;\u0026#34;\u0026#34; await ctx.send(f\u0026#34;Pong! {round(self.bot.latency * 1000)}ms\u0026#34;) Note that we're now using self as the first argument of the command function, because we're now in a class.\nNow we have another step we have to do before we run the bot (and I promise this extra effort will pay off in the long run when you understand the code better and can find things easier!) which is to add the cog to the bot. We do that like this:\nbot.add_cog(SomeCommands(bot)) That's it, we've added the cog to the bot, now we can run it in the normal way and test out our ping command now using cogs!\nbot.run(\u0026#34;your_token_here\u0026#34;)  This is a insecure way of setting the token used for brevity, please read this bonus part about storing tokens.  Great! It works! But we haven't really solved the problem we had before, which was having everything in one file, in fact we've added to the amount of code in the single file, which is doing the exact opposite of what we were trying to do. So, how do we solve this? Well, with more files of course! discord.py's Bot provides another useful function which is load_extension(), which will load cogs from another file.\nTo start with, let's set up the main bot file, we'll call it bot.py from now on with the following code (this is not the final code for this file, we'll update it in a bit to reflect the changes we are about to make):\nfrom discord.ext import commands bot = commands.Bot(command_prefix=\u0026#34;!\u0026#34;) bot.run(\u0026#34;your_token_here\u0026#34;)  This is a insecure way of setting the token used for brevity, please read this bonus part about storing tokens.  Basically, we've stripped most of the logic out because we're going to move that to another file, somecommands.py, so let's create that file and add some code:\nfrom discord.ext import commands # Again, we need this imported class SomeCommands(commands.Cog): \u0026#34;\u0026#34;\u0026#34;A couple of simple commands.\u0026#34;\u0026#34;\u0026#34; def __init__(self, bot: commands.Bot): self.bot = bot @commands.command(name=\u0026#34;ping\u0026#34;) async def ping(self, ctx: commands.Context): \u0026#34;\u0026#34;\u0026#34;Get the bot\u0026#39;s current websocket latency.\u0026#34;\u0026#34;\u0026#34; await ctx.send(f\u0026#34;Pong! {round(self.bot.latency * 1000)}ms\u0026#34;) # It\u0026#39;s now self.bot.latency  As you can see in the above examples, cog classes must derive from commands.Cog else they will not work.  Finally for this file, we need to add a setup function so that discord.py can load the cog:\ndef setup(bot: commands.Bot): bot.add_cog(SomeCommands(bot))  The name of this function must be setup as this is what discord.py will use to load it.  And that's most of the work done to move it into its own file, we just need to update bot.py to make it load this cog, because currently it has no idea there's a cog here that it needs to load. To do this we'll use the load_extension() function I mentioned earlier:\nfrom discord.ext import commands bot = commands.Bot(command_prefix=\u0026#34;!\u0026#34;) bot.load_extension(\u0026#34;somecommands\u0026#34;) # Note, we don\u0026#39;t need the .py file extension bot.run(\u0026#34;your_token_here\u0026#34;)  This is a insecure way of setting the token used for brevity, please read this bonus part about storing tokens.  That's it for the basics of cogs, you now know how to create a cog, create commands in that cog, and then load the cog into the bot!\nExtra reading discord.py actually provides us with a way to easily create new bots and cogs through its module's CLI. As a rough overwiew it provides the commands newbot and newcog, which auto generate bots and cogs respectively.\nnewbot This creates a new bot, by default in the current directory, with a given name. The avilable options are:\n name [required] : The bot's name. directory [optional, default=.] : The directory to create the bot in. prefix [optional, default=$] : The bot's prefix. sharded [optional] : Whether the bot should use AutoShardedClient  Note that sharding likely won't be of use to you until about 2,000 servers, and is enforced by the gateway at 2,500.   no-git : Whether the project should be created without a git project.  A command to create a typical new bot might look like this:\npython -m discord newbot TestBot --prefix !\nnewcog This creates a new cog in the cogs folder of the current directory by default, with a given name. The avilable options are:\n name [required] : The cog's name. directory [optional, default=cogs] : The directory to create the cog in. class-name [optional, default=[name]] : The cog's class name. display-name [optional, default=[name]] : The cog's display name. hide-commands [optional] : Whether to hide the commands in the cog from the help command. full [optional] : Whether to add special cog methods too.  A command to create a typical new cog might look like this:\npython -m discord newcog mycog\n Next: Online! ","link":"https://tutorial.vcokltfre.dev/tutorial/05-cogs/","title":"05 - Cogs"},{"body":"As with the previous part we'll want to import and set up the bot like below:\nfrom discord.ext import commands bot = commands.Bot(command_prefix=\u0026#34;!\u0026#34;) @bot.command(name=\u0026#34;hello\u0026#34;) async def hello_world(ctx: commands.Context): await ctx.send(\u0026#34;Hello, world!\u0026#34;) bot.run(\u0026#34;your_token_here\u0026#34;)  This is a insecure way of setting the token used for brevity, please read this bonus part about storing tokens.  But now we want to add another command between the hello command and where we run the bot. Note that if you put the command after running the bot it will never be called since running the bot creates a blocking loop, preventing execution of code after it, until the bot shuts down.\nThe command will look like this:\n@bot.command(name=\u0026#34;ping\u0026#34;) async def ping(ctx: commands.Context): await ctx.send(f\u0026#34;Pong! {round(bot.latency * 1000)}ms\u0026#34;) This will send a message that says something along the lines of \u0026quot;Pong! 113ms\u0026quot; which is the amount of time between discord.py sending a gateway heartbeat and it receiving an acknowledgement from the gateway. In the response we're using an f-string (Python 3.6 and above) so that we can use inline code within the string, in this case the bot's latency is measured in seconds, but we want it in milliseconds, so we multiply it by 1000 and round it to remove the decimals.\nIt's that simple, you've added another command, go ahead and run the bot to try it out! If it works it should look like the following:\nWell done! You're already 4 parts in, fortunately there's a lot more to learn, so you can now move on to the next part.\nNext: Cogs ","link":"https://tutorial.vcokltfre.dev/tutorial/04-pong/","title":"04 - A Ping Command"},{"body":"From now on it is assumed that you have the discord.py library installed, along with a version of Python which is 3.6 or above, as versions before this don’t have all the features used in this tutorial.\nThe first step to creating a bot is to import the discord.ext.commands module of discord.py so that we can create the bot:\nfrom discord.ext import commands # This is the part of discord.py that helps us build bots Epic! Now that we can use the discord.ext.commands module, we need to actually create a bot instance that will run our commands:\nbot = commands.Bot(command_prefix=\u0026#34;!\u0026#34;) As you can see, the first thing we need to do is tell the bot which command prefix to use, otherwise how can it know when a command is called and that it should respond?\nThis prefix can actually be one of many things, but for the sake of this tutorial I'll just be using the string \u0026quot;!\u0026quot; for the prefix. For now just know that it is possible to create more complex prefixes, such as a different prefix for each server.  The bot constructor is also where we would specify what are known as gateway intents - essentially telling the gateway which events we want. For now we'll ignore this, however it will be covered in part 7 when we need to use events not given with the default intents.\nNext, we want to add a command to the bot so that it can do something. The first command we'll add is a !hello command, that responds with \u0026quot;Hello, world!\u0026quot;\n@bot.command(name=\u0026#34;hello\u0026#34;) async def hello_world(ctx: commands.Context): await ctx.send(\u0026#34;Hello, world!\u0026#34;)  By default, the bot will ignore other bots messages, so sending !hello from another bot won't trigger the command.  That's quite a lot to take in, even if you're quite familiar with Python, so allow me to explain what each piece of it does:\n @bot.command(name=\u0026quot;hello\u0026quot;) is a decorator that converts the function below it into a command that you can run from Discord. async def hello_world(ctx: commands.Context): defines a hello_world function that takes 1 argument - ctx - which is a Context object that's passed with every command. All commands will be passed a Context object as their first argument. await ctx.send(\u0026quot;Hello, world!\u0026quot;) makes an API call to Discord to send a message to the channel the command was run in with the content \u0026quot;Hello, world!\u0026quot; Note that ctx.send() is an alias of ctx.channel.send(), and functions exactly the same, just in a more concise way.  Note that explicitly setting the name in the command decorator is optional, as without it the command will inherit the function name, and often will not be needed, whether to use it is up to you.  Next, we need to run the bot with its token that you got from the developer portal in 01 - Creating a Bot User:\nbot.run(\u0026#34;your_token_here\u0026#34;)  This is a insecure way of setting the token used for brevity, please read this bonus part about storing tokens.  This runs the bot with your token, and abstracts away creating an event loop and running the bot through coroutines.\nAt this point, your bot should be entirely functional, and if you start it up in your preferred method, you should see it come online and answer commands.\nCommon ways of starting your bot:\n running python bot.py pressing F5 in most IDEs   Next: A Ping Command ","link":"https://tutorial.vcokltfre.dev/tutorial/03-hello/","title":"03 - Hello, world!"},{"body":"If you already have a decent understanding of websockets, the API, and Discord terminology, you can likely move on to 03 - Hello, World!\n1: The Discord Gateway The Discord gateway is how your bot receives events from Discord, so understanding it can be useful to understand what a bot's capabilities are and what Discord gives you to work with.\nSo, what actually is this Discord Gateway you keep mentioning? The gateway is actually a fairly simple websocket connection to Discord - basically a web request that connects a socket, which then stays open so that Discord can send events to you, rather than you fetching events from Discord. Neat, huh?\nWhile you're using discord.py you don't actually have to worry about connecting to the gateway yourself, because the library does that all for you, but I believe nonetheless it's useful to have an understanding of how the underlying architecture works, which often makes the higher level stuff make more sense.\nWhen discord.py receives an event from the gateway it will have an OPCODE and some event data, and a couple of other pieces of data we won't worry about for now. These tell your client what to do with the payload, such as hearbeating to the gateway to show the client is still alive.\nIf the OPCODE passed is 0, that means it's a dispatch event, and those are the ones we're interested in, because they contain the interesting events like message creations, member joins, and any other typical Discord event like them.\nThat's pretty much it for the gateway at this level. There is a lot more detail that can be talked about with the gateway, but that's out of the scope of this tutorial, and if you're interested in further reading the official Discord documentation for the gateway can be found here.\n2: The API The Discord API is how our bot talks back to Discord. We've got the events from the gateway and we've processed them, but without the API we can't actually do anything with that. If you've ever sent a message on Discord, added a reaction, renamed a channel, or performed almost any other action, you've made API requests to the Discord API to do that.\nWell, bots are much the same, only they don't have access to all the same endpoints as the user client (although, that being said they do have access to a couple of exclusive endpoints, like locking the use of an emoji to a specific role!).\nAgain, as with the gateway, discord.py handles interaction with the API and abstracts away most of the complexity like passing tokens in headers and handling ratelimits.\n3: Discord Terminology In Discord there are a few special words for things which we need to understand and be able to differentiate between.\n   Term Description     guild The internal word that Discord has for what you know as a server.   user A Discord user, not containing information relating to a guild.   member A Discord user, with guild context. You'll only receive members if you have the server members gateway intent enabled, which will be explained later, or sometimes in other events like voice state updates and as the author in message events.    And that's pretty much it for this part of the tutorial. I hope this has given you at least some useful knowledge about roughly how Discord works, and now you can move on to the next part!\nNext: Hello, world! ","link":"https://tutorial.vcokltfre.dev/tutorial/02-overview/","title":"02 - An Overview of Discord"},{"body":" To create Discord applications and bots you will need a verified email address.  The first thing you need to do to create a bot is head over to the Discord Developer Portal where you'll be asked to log in to your Discord account. Upon logging in you'll see a screen like this:\nNow that you're logged into the developer portal you need to create a new application by clicking the shiny blue New Application button in the top right hand corner. After you click it you should see a box like this pop up:\nBe sure to enter a suitable and good name for your bot - and be sure to follow the Discord Terms of Service, so no slurs or harassment. To be clear this applies to the entire tutorial and you should not use any of the knowledge you gain from it to perform actions that are not allowed by it. You can read the Terms of Service here, and the Developer Terms here.\nAs a rough overview here are some things you should know about the ToS:\n Don't abuse the API Don't harass users.  So don't randomly DM or spam them.   Don't spam Discord.  Generally actions performed by a bot should be caused by some user action like sending a message or adding a reaction.   Don't post NSFW content in channels not marked as NSFW.  This may seem obvious but a lot of bots allow NSFW content to be posted outside of NSFW channels. This is not allowed.     For this tutorial the bot will be named WumpusBot and will be referred to as that elsewhere in the tutorial.\nAfter creating your application you'll see a screen like this:\nYou likely want to set your bot to private - at least while testing - so that other people can't add your bot to their servers.  There's quite a lot of information on this screen, so for now we'll ignore most of it since it's out of scope for the beginning of this tutorial. Click on the Bot tab on the left hand side (marked by a jigsaw piece) to switch to the bot page. On this page you'll see a button that says Add Bot. Clicking this will prompt you if you're sure you want to create a new bot (you can't delete bots since they're too cool to destroy), click Yes, do it! and now you have your very own bot.\nAfter creating a bot your screen will change to look like this:\nBelow the username box you'll see a button that says Copy which copies your bot's authentication token to your clipboard. You'll want to keep this token safe and on hand so your bot can connect to Discord later on in the tutorial.\nFinally for this part, you need to add your bot to your server. To do this you first require the Manage Server permission in whatever server you plan on adding it to. You’ll want to head over to the OAuth2 tab on the left of the developer portal (marked by a wrench), where you’ll be able to choose the scopes you want for your bot. For now, just select the bot scope, as it’s all that will be needed for this tutorial - at least at the beginning.\nNow you’ll want to choose permissions for your bot based on what you want it to do. For WumpusBot, I’ll start by giving it Send Messages, Embed Links, Attach Files, Manage Messages, and Add Reactions, although we may need more permissions later, but that will be handled within Discord itself.\nIt is highly recommended that you never give bots the Administrator permission, even if it feels easier than giving the bot just what’s needed. Please do not give your bots administrator.  In the end your permissions should look like this:\nNow you can copy the URL in the box above, and paste it into your browser, then follow the steps to add the bot to your server of choice.\nThat's it for the first part of the tutorial, you've created your very own bot user on Discord. Now you just have to do the fun bit - adding features - after all, what's a bot without features?\nA quick note on tokens: You should make an effort to keep your token safe at all times. This means not sharing it with anyone or accidentally uploading it in code samples. If someone gains access to your bot’s token they then have full control of the bot, and can perform actions with it that you may not want. If you believe that your bot’s token was leaked, be sure to go to it’s developer portal page and click the Regenerate button to regenerate the token so that nobody can use the old one.\nFor more info in how you should store tokens see this bonus part.\n Next: An Overview of Discord ","link":"https://tutorial.vcokltfre.dev/tutorial/01-setup/","title":"01 - Creating a Bot User"},{"body":"This is a page to show credits and special thanks for help people have provided with this tutorial, or things within it.\nFirstly, thanks to Danny/Rapptz for making discord.py, without which this tutorial would obviously not exist, nor would countless amazing bots using the discord.py library. His Github profile can be found here.\nNext, anand/ares initially helped me a great deal with getting the site up on Github pages, and making the first pages version. A link to their Github profile can be found here.\nEnormous thanks to TizzySaurus for sitting for about 2.5 hours with me going through every part making sure it was correct, fixing spelling errors, formatting, and making a bunch more awesome suggestions. I don't know your Github profile, but you helped so much so thanks!\nFinally, as much as I don't want to, apparently I should give myself credit, so my Github profile can be found here :P, you can support me on Ko-fi here, and the repo for this tutorial can be found here.\nBack to the Index ","link":"https://tutorial.vcokltfre.dev/tutorial/00-credits/","title":"00 - Credits and Special Thanks"},{"body":" The discord.py library has now been discontinued by its maintainer. This tutorial will still work for discord.py versions 1.6.0-1.7.3 but some parts may be broken in version 2.0.0 upwards, which is what most forks of the library are based on. Many of these libraries such as pycord, nextcord, and disnake provide shims that allow you to continue using the discord namespace, however, and so it is still possible to use most of this tutorial with those libraries too.\nCurrently I'm unsure on the future of this tutorial. I love making Discord bots, the Python language, and making content to help other people learn about both of those things, but in the current unstable state of the Discord bot ecosystem in Python I don't feel comfortable creating any more content around it until I can be sure that the library I choose to go with will stick around and my work won't be for nothing.\nI would, however, like to say that having looked at several of the available libraries (pycord, nextcord, and disnake) I believe there is one clear winner at the moment, due to its similarity in style to the original discord.py, intelligent and sensible design decisions, and generally the direction it's going in: disnake. This is the library that I personally would like to see win this battle, as its design decisions seem well thought out, specially the implementation of slash commands.\n A tutorial aiming to provide a detailed explanation of how to create a custom Discord bot using the discord.py library. This tutorial will walk you through all the aspects of creating your own bot, from creating the bot user itself on the Discord developer portal, to a brief overview of the Discord websocket gateway and HTTP API, to programming the bot itself.\n Some Notes Before Starting For this tutorial you will need:\n Python 3.6 or later installed discord.py 1.6.0 or later installed Intermediate Python experience or a strong will to learn  An incredibly useful resource to you throughout the tutorial will be the discord.py documentation\nIf you find something amiss with the tutorial, or have a suggestion to improve it please create an issue on the repo.\n The discord.py library is an advanced Python library. As such a certain amount of intermediate Python knowledge is assumed in this tutorial, and basic Python functionality will be not covered or explained. That being said, if you're willing to learn and search for things you don't understand as you follow along, there's no reason you shouldn't be able to participate.  The premise of this tutorial is that you write code yourself, and understand what you are writing. I aim to explain what I'm doing, and clarify the decisions I make, but this tutorial will not help you if you choose to copy and paste its content rather than try to understand and work it out for yourself. I highly recommend you play around with the code you write and make it different from what you see here. This is to help you learn how to use discord.py, not to give you the code for a bot.   Index  00 - Credits and Special Thanks 01 - Creating a Bot User 02 - An Overview of Discord 03 - Hello, world! 04 - A Ping Command 05 - Cogs 06 - Online! 07 - Welcome 08 - A Better Ping Command 09 - What Did That Message Say? 10 - All About Embeds 11 - Cooldowns 12 - Error Handling 13 - Permissions 14 - Converters 15 - Waiting  Extras  Tips - Allowed Mentions Tips - Blocking Calls Tips - Client vs Bot Tips - Cogs vs Main Tips - Gateway Intents Tips - Storing Data Tips - Tokens   Start the Tutorial!  If this tutorial has helped you, please consider supporting me on Ko-fi so that I can keep working on projects like this :P\n","link":"https://tutorial.vcokltfre.dev/","title":"discord.py Bot Tutorial"},{"body":"Index  00 - Credits and Special Thanks 01 - Creating a Bot User 02 - An Overview of Discord 03 - Hello, world! 04 - A Ping Command 05 - Cogs 06 - Online! 07 - Welcome 08 - A Better Ping Command 09 - What Did That Message Say? 10 - All About Embeds 11 - Cooldowns 12 - Error Handling 13 - Permissions 14 - Converters 15 - Waiting   Start the Tutorial! See the Credits! ","link":"https://tutorial.vcokltfre.dev/tutorial/","title":"discord.py Bot Tutorial"}]